
SoccerGame.elf:     file format elf32-littlenios2
SoccerGame.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00088020

Program Header:
    LOAD off    0x00001000 vaddr 0x00088000 paddr 0x00088000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00088020 paddr 0x00088020 align 2**12
         filesz 0x0000363c memsz 0x0000363c flags r-x
    LOAD off    0x0000465c vaddr 0x0008b65c paddr 0x0008b984 align 2**12
         filesz 0x00000328 memsz 0x00000328 flags rw-
    LOAD off    0x00004cac vaddr 0x0008bcac paddr 0x0008bcac align 2**12
         filesz 0x00000000 memsz 0x00000010 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00088000  00088000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         000035ec  00088020  00088020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000050  0008b60c  0008b60c  0000460c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rwdata       00000328  0008b65c  0008b984  0000465c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  4 .bss          00000010  0008bcac  0008bcac  00004cac  2**2
                  ALLOC, SMALL_DATA
  5 .comment      00000026  00000000  00000000  00004984  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000348  00000000  00000000  000049b0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 000006ba  00000000  00000000  00004cf8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00005e31  00000000  00000000  000053b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000013ee  00000000  00000000  0000b1e3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00004fc8  00000000  00000000  0000c5d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000006c8  00000000  00000000  0001159c  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000009ca  00000000  00000000  00011c64  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00000b18  00000000  00000000  0001262e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_alt_sim_info 00000050  00000000  00000000  00013148  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000038  00000000  00000000  00013198  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .thread_model 00000003  00000000  00000000  000147e0  2**0
                  CONTENTS, READONLY
 17 .cpu          00000003  00000000  00000000  000147e3  2**0
                  CONTENTS, READONLY
 18 .qsys         00000001  00000000  00000000  000147e6  2**0
                  CONTENTS, READONLY
 19 .simulation_enabled 00000001  00000000  00000000  000147e7  2**0
                  CONTENTS, READONLY
 20 .stderr_dev   00000004  00000000  00000000  000147e8  2**0
                  CONTENTS, READONLY
 21 .stdin_dev    00000004  00000000  00000000  000147ec  2**0
                  CONTENTS, READONLY
 22 .stdout_dev   00000004  00000000  00000000  000147f0  2**0
                  CONTENTS, READONLY
 23 .sopc_system_name 0000000c  00000000  00000000  000147f4  2**0
                  CONTENTS, READONLY
 24 .quartus_project_dir 00000016  00000000  00000000  00014800  2**0
                  CONTENTS, READONLY
 25 .sopcinfo     00053d69  00000000  00000000  00014816  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00088000 l    d  .entry	00000000 .entry
00088020 l    d  .text	00000000 .text
0008b60c l    d  .rodata	00000000 .rodata
0008b65c l    d  .rwdata	00000000 .rwdata
0008bcac l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00088058 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 Soccer.c
00000000 l    df *ABS*	00000000 alt_load.c
00089114 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0008b65c l     O .rwdata	0000002c jtag_uart_0
0008b688 l     O .rwdata	00000054 Pixel_Buffer_DMA
0008944c l     F .text	00000038 alt_dev_reg
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_up_avalon_video_pixel_buffer_dma.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
0008ae90 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
0008af0c l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0008afec l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0008b29c l     F .text	00000004 register_fini
00000000 l    df *ABS*	00000000 impure.c
0008b884 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 lib2-divmod.c
0008b45c l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 alt_exit.c
0008b5a8 l     F .text	00000040 alt_sim_halt
00089180 g     F .text	00000040 alt_main
0008a348 g     F .text	000003d0 alt_up_pixel_buffer_dma_draw_vline
0008b984 g       *ABS*	00000000 __flash_rwdata_start
0008845c g     F .text	0000010c initialPic
0008971c g     F .text	000001a0 alt_up_pixel_buffer_dma_draw
00000000  w      *UND*	00000000 __errno
000896dc g     F .text	00000040 alt_up_pixel_buffer_dma_open_dev
00088000 g     F .entry	0000001c __reset
00088020 g       *ABS*	00000000 __flash_exceptions_start
0008bcb8 g     O .bss	00000004 errno
0008bcb0 g     O .bss	00000004 alt_argv
00093964 g       *ABS*	00000000 _gp
000891c0 g     F .text	00000030 usleep
000898bc g     F .text	00000058 alt_up_pixel_buffer_dma_change_back_buffer_address
0008b704 g     O .rwdata	00000180 alt_fd_list
0008b04c g     F .text	00000094 alt_find_dev
0008996c g     F .text	00000034 alt_up_pixel_buffer_dma_check_swap_buffers_status
00089534 g     F .text	00000104 altera_avalon_jtag_uart_read
0008b598 g     F .text	00000008 __udivsi3
00088568 g     F .text	00000b2c AnimPlay
00089ff8 g     F .text	00000350 alt_up_pixel_buffer_dma_draw_hline
0008b190 g     F .text	00000090 alt_icache_flush
0008a7dc g     F .text	000000d0 helper_plot_pixel
0008b974 g     O .rwdata	00000004 alt_max_fd
000899a0 g     F .text	00000164 alt_up_pixel_buffer_dma_clear_screen
0008b980 g     O .rwdata	00000004 _global_impure_ptr
0008bcbc g       *ABS*	00000000 __bss_end
00089b04 g     F .text	000004f4 alt_up_pixel_buffer_dma_draw_box
0008b6dc g     O .rwdata	00000028 alt_dev_null
0008aef0 g     F .text	0000001c alt_dcache_flush_all
0008a718 g     F .text	000000c4 alt_up_pixel_buffer_dma_draw_rectangle
0008b984 g       *ABS*	00000000 __ram_rwdata_end
0008b96c g     O .rwdata	00000008 alt_dev_list
0008a8ac g     F .text	0000039c alt_up_pixel_buffer_dma_draw_line
0008b65c g       *ABS*	00000000 __ram_rodata_end
0008b5a0 g     F .text	00000008 __umodsi3
0008bcbc g       *ABS*	00000000 end
0008be80 g       *ABS*	00000000 __alt_stack_pointer
00089638 g     F .text	000000a4 altera_avalon_jtag_uart_write
0008b2a0 g     F .text	000001bc __call_exitprocs
00088020 g     F .text	0000003c _start
00089224 g     F .text	00000228 alt_sys_init
0008b65c g       *ABS*	00000000 __ram_rwdata_start
0008b60c g       *ABS*	00000000 __ram_rodata_start
00089484 g     F .text	00000058 altera_avalon_jtag_uart_read_fd
0008ac48 g     F .text	0000014c alt_busy_sleep
0008b240 g     F .text	0000003c memcmp
0008bcbc g       *ABS*	00000000 __alt_stack_base
0008af38 g     F .text	000000b4 alt_dev_llist_insert
0008bcac g       *ABS*	00000000 __bss_start
0008805c g     F .text	00000400 main
0008bcb4 g     O .bss	00000004 alt_envp
00089914 g     F .text	00000058 alt_up_pixel_buffer_dma_swap_buffers
000894dc g     F .text	00000058 altera_avalon_jtag_uart_write_fd
0008b978 g     O .rwdata	00000004 alt_errno
0008b4d8 g     F .text	00000060 __divsi3
0008b60c g       *ABS*	00000000 __flash_rodata_start
000891f0 g     F .text	00000034 alt_irq_init
0008b110 g     F .text	00000060 alt_release_fd
0008b97c g     O .rwdata	00000004 _impure_ptr
0008bcac g     O .bss	00000004 alt_argc
0008b964 g     O .rwdata	00000008 alt_fs_list
00088020 g       *ABS*	00000000 __ram_exceptions_start
0008b984 g       *ABS*	00000000 _edata
0008bcbc g       *ABS*	00000000 _end
00088020 g       *ABS*	00000000 __ram_exceptions_end
00088000 g       *ABS*	00000000 __alt_mem_Onchip_Memory
0008b170 g     F .text	00000020 altera_nios2_qsys_irq_init
0008b220 g     F .text	00000020 exit
0008b538 g     F .text	00000060 __modsi3
0008be80 g       *ABS*	00000000 __alt_data_end
0008b5e8 g     F .text	00000020 _exit
0008b27c g     F .text	00000020 strlen
0008b0e0 g     F .text	00000030 alt_icache_flush_all
0008ad94 g     F .text	000000fc close
00089094 g     F .text	00000080 alt_load
00000000  w      *UND*	00000000 free



Disassembly of section .entry:

00088000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
   88000:	00810014 	movui	r2,1024
#endif

0:
    initi r2
   88004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
   88008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
   8800c:	00bffd16 	blt	zero,r2,88004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   88010:	00400234 	movhi	at,8
    ori r1, r1, %lo(_start)
   88014:	08600814 	ori	at,at,32800
    jmp r1
   88018:	0800683a 	jmp	at
   8801c:	00000000 	call	0 <__reset-0x88000>

Disassembly of section .text:

00088020 <_start>:
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   88020:	06c00234 	movhi	sp,8
    ori sp, sp, %lo(__alt_stack_pointer)
   88024:	deefa014 	ori	sp,sp,48768

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
   88028:	06800274 	movhi	gp,9
    ori gp, gp, %lo(_gp)
   8802c:	d68e5914 	ori	gp,gp,14692
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   88030:	00800234 	movhi	r2,8
    ori r2, r2, %lo(__bss_start)
   88034:	10af2b14 	ori	r2,r2,48300

    movhi r3, %hi(__bss_end)
   88038:	00c00234 	movhi	r3,8
    ori r3, r3, %lo(__bss_end)
   8803c:	18ef2f14 	ori	r3,r3,48316

    beq r2, r3, 1f
   88040:	10c00326 	beq	r2,r3,88050 <_start+0x30>

0:
    stw zero, (r2)
   88044:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   88048:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   8804c:	10fffd36 	bltu	r2,r3,88044 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   88050:	00890940 	call	89094 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   88054:	00891800 	call	89180 <alt_main>

00088058 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   88058:	003fff06 	br	88058 <alt_after_alt_main>

0008805c <main>:
#include "altera_up_avalon_video_pixel_buffer_dma.h"
/*############################################################## FUNCTION CALL ##################################################################*/
void initialPic();
void AnimPlay(int Result);

int main(void) {
   8805c:	defff104 	addi	sp,sp,-60
   88060:	dfc00e15 	stw	ra,56(sp)
   88064:	df000d15 	stw	fp,52(sp)
   88068:	df000d04 	addi	fp,sp,52
	 *   3 for game result calculation.
	 *   4 for Anim playing.
	 *   5 for EXIT the game.
	 *   6 for Idle, waiting for start the game.
	 */
	int GameState = 6;//----------------------------------------------------------------Default to enter Idle state
   8806c:	00800184 	movi	r2,6
   88070:	e0bfff15 	stw	r2,-4(fp)
	int Round = 1; //-------------------------------------------------------------------To count the total number of round played.
   88074:	00800044 	movi	r2,1
   88078:	e0bffe15 	stw	r2,-8(fp)
	int Score_1 = 0, Score_2 = 0; //----------------------------------------------------To count the score for both players.
   8807c:	e03ffd15 	stw	zero,-12(fp)
   88080:	e03ffc15 	stw	zero,-16(fp)
	int Direction_1 = 0, Direction_2 = 0; //--------------------------------------------To record the direction chosen for each player.
   88084:	e03ffb15 	stw	zero,-20(fp)
   88088:	e03ffa15 	stw	zero,-24(fp)
	 *  6 for center        - right
	 *  7 for right         - left
	 *  8 for right         - center
	 *  9 for right         - right
	 */
	int GameResult = 0;
   8808c:	e03ff915 	stw	zero,-28(fp)


	alt_up_pixel_buffer_dma_dev* EnableDev;
	EnableDev = alt_up_pixel_buffer_dma_open_dev("/dev/Pixel_Buffer_DMA"); //-----------Enable the VGA Device
   88090:	01000274 	movhi	r4,9
   88094:	212d8304 	addi	r4,r4,-18932
   88098:	00896dc0 	call	896dc <alt_up_pixel_buffer_dma_open_dev>
   8809c:	e0bff815 	stw	r2,-32(fp)
	alt_up_pixel_buffer_dma_clear_screen(EnableDev, 0); //Clean the Screen
   880a0:	e13ff817 	ldw	r4,-32(fp)
   880a4:	000b883a 	mov	r5,zero
   880a8:	00899a00 	call	899a0 <alt_up_pixel_buffer_dma_clear_screen>

	while (1) { //----------------------------------------------------------------------Enter the main loop.
/*############################################################## STATE 0 ##################################################################*/
		while (GameState == 0) { //-----------------------------------------------------State for START game and display the Title/Name.
   880ac:	00000a06 	br	880d8 <main+0x7c>
			// Display the title 'Soccer Game', 'EE 3921 Final Project', 'Ziwei.C and Zhaoming.Q'
			usleep(500000); //----------------------------------------------------------Wait/sleep for 10 seconds.
   880b0:	01000234 	movhi	r4,8
   880b4:	21284804 	addi	r4,r4,-24288
   880b8:	00891c00 	call	891c0 <usleep>
			initialPic(); //------------------------------------------------------------Display the initial picture for game.
   880bc:	008845c0 	call	8845c <initialPic>
			// Reset all variables to its initial values.
			Round = 1; //---------------------------------------------------------------To count the total number of round played.
   880c0:	00800044 	movi	r2,1
   880c4:	e0bffe15 	stw	r2,-8(fp)
			Score_1 = 0, Score_2 = 0; //------------------------------------------------To count the score for both players.
   880c8:	e03ffd15 	stw	zero,-12(fp)
   880cc:	e03ffc15 	stw	zero,-16(fp)
			GameState = 1; //---------------------------------------------------------- Enter State 1, for the first player to choose direction.
   880d0:	00800044 	movi	r2,1
   880d4:	e0bfff15 	stw	r2,-4(fp)
	EnableDev = alt_up_pixel_buffer_dma_open_dev("/dev/Pixel_Buffer_DMA"); //-----------Enable the VGA Device
	alt_up_pixel_buffer_dma_clear_screen(EnableDev, 0); //Clean the Screen

	while (1) { //----------------------------------------------------------------------Enter the main loop.
/*############################################################## STATE 0 ##################################################################*/
		while (GameState == 0) { //-----------------------------------------------------State for START game and display the Title/Name.
   880d8:	e0bfff17 	ldw	r2,-4(fp)
   880dc:	1005003a 	cmpeq	r2,r2,zero
   880e0:	103ff31e 	bne	r2,zero,880b0 <main+0x54>
			Round = 1; //---------------------------------------------------------------To count the total number of round played.
			Score_1 = 0, Score_2 = 0; //------------------------------------------------To count the score for both players.
			GameState = 1; //---------------------------------------------------------- Enter State 1, for the first player to choose direction.
		}
/*############################################################## STATE 1 ##################################################################*/
		while (GameState == 1) { //-----------------------------------------------------State for the first player to choose direction.
   880e4:	00001606 	br	88140 <main+0xe4>
			// Display: 'Penalty Taker choose direction', 'Press Key 0,1,2' to choose left, center, or right'.
			int Dir_temp_1 = Direction_1;
   880e8:	e0bffb17 	ldw	r2,-20(fp)
   880ec:	e0bff715 	stw	r2,-36(fp)
			while (Dir_temp_1 == Direction_1) {
   880f0:	00000406 	br	88104 <main+0xa8>
				Direction_1 = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE); //-------------Read the Input from key, and store the value in Direction_1.
   880f4:	00800274 	movhi	r2,9
   880f8:	10840004 	addi	r2,r2,4096
   880fc:	10800037 	ldwio	r2,0(r2)
   88100:	e0bffb15 	stw	r2,-20(fp)
		}
/*############################################################## STATE 1 ##################################################################*/
		while (GameState == 1) { //-----------------------------------------------------State for the first player to choose direction.
			// Display: 'Penalty Taker choose direction', 'Press Key 0,1,2' to choose left, center, or right'.
			int Dir_temp_1 = Direction_1;
			while (Dir_temp_1 == Direction_1) {
   88104:	e0fff717 	ldw	r3,-36(fp)
   88108:	e0bffb17 	ldw	r2,-20(fp)
   8810c:	18bff926 	beq	r3,r2,880f4 <main+0x98>
				Direction_1 = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE); //-------------Read the Input from key, and store the value in Direction_1.
			}
			Dir_temp_1 = Direction_1;
   88110:	e0bffb17 	ldw	r2,-20(fp)
   88114:	e0bff715 	stw	r2,-36(fp)
			while (Dir_temp_1 != 15) {
   88118:	00000406 	br	8812c <main+0xd0>
				Dir_temp_1 = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE); //--------------Read the Input from key, and store the value in Direction_1.
   8811c:	00800274 	movhi	r2,9
   88120:	10840004 	addi	r2,r2,4096
   88124:	10800037 	ldwio	r2,0(r2)
   88128:	e0bff715 	stw	r2,-36(fp)
			int Dir_temp_1 = Direction_1;
			while (Dir_temp_1 == Direction_1) {
				Direction_1 = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE); //-------------Read the Input from key, and store the value in Direction_1.
			}
			Dir_temp_1 = Direction_1;
			while (Dir_temp_1 != 15) {
   8812c:	e0bff717 	ldw	r2,-36(fp)
   88130:	108003d8 	cmpnei	r2,r2,15
   88134:	103ff91e 	bne	r2,zero,8811c <main+0xc0>
				Dir_temp_1 = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE); //--------------Read the Input from key, and store the value in Direction_1.
			}
			GameState = 2; //-----------------------------------------------------------Enter State 2, for the second player to choose Direction.
   88138:	00800084 	movi	r2,2
   8813c:	e0bfff15 	stw	r2,-4(fp)
			Round = 1; //---------------------------------------------------------------To count the total number of round played.
			Score_1 = 0, Score_2 = 0; //------------------------------------------------To count the score for both players.
			GameState = 1; //---------------------------------------------------------- Enter State 1, for the first player to choose direction.
		}
/*############################################################## STATE 1 ##################################################################*/
		while (GameState == 1) { //-----------------------------------------------------State for the first player to choose direction.
   88140:	e0bfff17 	ldw	r2,-4(fp)
   88144:	10800060 	cmpeqi	r2,r2,1
   88148:	103fe71e 	bne	r2,zero,880e8 <main+0x8c>
				Dir_temp_1 = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE); //--------------Read the Input from key, and store the value in Direction_1.
			}
			GameState = 2; //-----------------------------------------------------------Enter State 2, for the second player to choose Direction.
		}
/*############################################################## STATE 2 ##################################################################*/
		while (GameState == 2) { //-----------------------------------------------------State for the second player to choose direction.
   8814c:	00001606 	br	881a8 <main+0x14c>
			// Display: 'Goal Keeper choose direction', 'Press Key 0,1,2' to choose left, center, or right'.
			int Dir_temp_2 = Direction_2;
   88150:	e0bffa17 	ldw	r2,-24(fp)
   88154:	e0bff615 	stw	r2,-40(fp)
			while (Dir_temp_2 == Direction_2) {
   88158:	00000406 	br	8816c <main+0x110>
				Direction_2 = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE); //-------------Read the Input from key, and store the value in Direction_2.
   8815c:	00800274 	movhi	r2,9
   88160:	10840004 	addi	r2,r2,4096
   88164:	10800037 	ldwio	r2,0(r2)
   88168:	e0bffa15 	stw	r2,-24(fp)
		}
/*############################################################## STATE 2 ##################################################################*/
		while (GameState == 2) { //-----------------------------------------------------State for the second player to choose direction.
			// Display: 'Goal Keeper choose direction', 'Press Key 0,1,2' to choose left, center, or right'.
			int Dir_temp_2 = Direction_2;
			while (Dir_temp_2 == Direction_2) {
   8816c:	e0fff617 	ldw	r3,-40(fp)
   88170:	e0bffa17 	ldw	r2,-24(fp)
   88174:	18bff926 	beq	r3,r2,8815c <main+0x100>
				Direction_2 = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE); //-------------Read the Input from key, and store the value in Direction_2.
			}
			Dir_temp_2 = Direction_2;
   88178:	e0bffa17 	ldw	r2,-24(fp)
   8817c:	e0bff615 	stw	r2,-40(fp)
			while (Dir_temp_2 != 15) {
   88180:	00000406 	br	88194 <main+0x138>
				Dir_temp_2 = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE); //--------------Read the Input from key, and store the value in Direction_2.
   88184:	00800274 	movhi	r2,9
   88188:	10840004 	addi	r2,r2,4096
   8818c:	10800037 	ldwio	r2,0(r2)
   88190:	e0bff615 	stw	r2,-40(fp)
			int Dir_temp_2 = Direction_2;
			while (Dir_temp_2 == Direction_2) {
				Direction_2 = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE); //-------------Read the Input from key, and store the value in Direction_2.
			}
			Dir_temp_2 = Direction_2;
			while (Dir_temp_2 != 15) {
   88194:	e0bff617 	ldw	r2,-40(fp)
   88198:	108003d8 	cmpnei	r2,r2,15
   8819c:	103ff91e 	bne	r2,zero,88184 <main+0x128>
				Dir_temp_2 = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE); //--------------Read the Input from key, and store the value in Direction_2.
			}
			GameState = 3; //-----------------------------------------------------------Enter State 3, for result computation
   881a0:	008000c4 	movi	r2,3
   881a4:	e0bfff15 	stw	r2,-4(fp)
				Dir_temp_1 = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE); //--------------Read the Input from key, and store the value in Direction_1.
			}
			GameState = 2; //-----------------------------------------------------------Enter State 2, for the second player to choose Direction.
		}
/*############################################################## STATE 2 ##################################################################*/
		while (GameState == 2) { //-----------------------------------------------------State for the second player to choose direction.
   881a8:	e0bfff17 	ldw	r2,-4(fp)
   881ac:	108000a0 	cmpeqi	r2,r2,2
   881b0:	103fe71e 	bne	r2,zero,88150 <main+0xf4>
				Dir_temp_2 = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE); //--------------Read the Input from key, and store the value in Direction_2.
			}
			GameState = 3; //-----------------------------------------------------------Enter State 3, for result computation
		}
/*############################################################## STATE 3 ##################################################################*/
		while (GameState == 3) { //-----------------------------------------------------State for compute the result for game.
   881b4:	00005806 	br	88318 <main+0x2bc>
			/*
			 * Compare the value for direction to decide the game result, and Store the result in GameResult.
			 */
			GameResult = 0;
   881b8:	e03ff915 	stw	zero,-28(fp)
			if (Direction_1 == 11 && Direction_2 == 11) {//----------------------------left - left
   881bc:	e0bffb17 	ldw	r2,-20(fp)
   881c0:	108002d8 	cmpnei	r2,r2,11
   881c4:	1000061e 	bne	r2,zero,881e0 <main+0x184>
   881c8:	e0bffa17 	ldw	r2,-24(fp)
   881cc:	108002d8 	cmpnei	r2,r2,11
   881d0:	1000031e 	bne	r2,zero,881e0 <main+0x184>
				GameResult = 1; //-----------------------------------------------------Save the goal
   881d4:	00800044 	movi	r2,1
   881d8:	e0bff915 	stw	r2,-28(fp)
		while (GameState == 3) { //-----------------------------------------------------State for compute the result for game.
			/*
			 * Compare the value for direction to decide the game result, and Store the result in GameResult.
			 */
			GameResult = 0;
			if (Direction_1 == 11 && Direction_2 == 11) {//----------------------------left - left
   881dc:	00004706 	br	882fc <main+0x2a0>
				GameResult = 1; //-----------------------------------------------------Save the goal
			} else if (Direction_1 == 11 && Direction_2 == 13) { //--------------------left - center
   881e0:	e0bffb17 	ldw	r2,-20(fp)
   881e4:	108002d8 	cmpnei	r2,r2,11
   881e8:	1000061e 	bne	r2,zero,88204 <main+0x1a8>
   881ec:	e0bffa17 	ldw	r2,-24(fp)
   881f0:	10800358 	cmpnei	r2,r2,13
   881f4:	1000031e 	bne	r2,zero,88204 <main+0x1a8>
				GameResult = 2;
   881f8:	00800084 	movi	r2,2
   881fc:	e0bff915 	stw	r2,-28(fp)
			 * Compare the value for direction to decide the game result, and Store the result in GameResult.
			 */
			GameResult = 0;
			if (Direction_1 == 11 && Direction_2 == 11) {//----------------------------left - left
				GameResult = 1; //-----------------------------------------------------Save the goal
			} else if (Direction_1 == 11 && Direction_2 == 13) { //--------------------left - center
   88200:	00003e06 	br	882fc <main+0x2a0>
				GameResult = 2;
			} else if (Direction_1 == 11 && Direction_2 == 14) { //--------------------left - right
   88204:	e0bffb17 	ldw	r2,-20(fp)
   88208:	108002d8 	cmpnei	r2,r2,11
   8820c:	1000061e 	bne	r2,zero,88228 <main+0x1cc>
   88210:	e0bffa17 	ldw	r2,-24(fp)
   88214:	10800398 	cmpnei	r2,r2,14
   88218:	1000031e 	bne	r2,zero,88228 <main+0x1cc>
				GameResult = 3;
   8821c:	008000c4 	movi	r2,3
   88220:	e0bff915 	stw	r2,-28(fp)
			GameResult = 0;
			if (Direction_1 == 11 && Direction_2 == 11) {//----------------------------left - left
				GameResult = 1; //-----------------------------------------------------Save the goal
			} else if (Direction_1 == 11 && Direction_2 == 13) { //--------------------left - center
				GameResult = 2;
			} else if (Direction_1 == 11 && Direction_2 == 14) { //--------------------left - right
   88224:	00003506 	br	882fc <main+0x2a0>
				GameResult = 3;
			} else if (Direction_1 == 13 && Direction_2 == 11) { //--------------------center - left
   88228:	e0bffb17 	ldw	r2,-20(fp)
   8822c:	10800358 	cmpnei	r2,r2,13
   88230:	1000061e 	bne	r2,zero,8824c <main+0x1f0>
   88234:	e0bffa17 	ldw	r2,-24(fp)
   88238:	108002d8 	cmpnei	r2,r2,11
   8823c:	1000031e 	bne	r2,zero,8824c <main+0x1f0>
				GameResult = 4;
   88240:	00800104 	movi	r2,4
   88244:	e0bff915 	stw	r2,-28(fp)
				GameResult = 1; //-----------------------------------------------------Save the goal
			} else if (Direction_1 == 11 && Direction_2 == 13) { //--------------------left - center
				GameResult = 2;
			} else if (Direction_1 == 11 && Direction_2 == 14) { //--------------------left - right
				GameResult = 3;
			} else if (Direction_1 == 13 && Direction_2 == 11) { //--------------------center - left
   88248:	00002c06 	br	882fc <main+0x2a0>
				GameResult = 4;
			} else if (Direction_1 == 13 && Direction_2 == 13) { //--------------------center - center
   8824c:	e0bffb17 	ldw	r2,-20(fp)
   88250:	10800358 	cmpnei	r2,r2,13
   88254:	1000061e 	bne	r2,zero,88270 <main+0x214>
   88258:	e0bffa17 	ldw	r2,-24(fp)
   8825c:	10800358 	cmpnei	r2,r2,13
   88260:	1000031e 	bne	r2,zero,88270 <main+0x214>
				GameResult = 5; //-----------------------------------------------------Save the goal
   88264:	00800144 	movi	r2,5
   88268:	e0bff915 	stw	r2,-28(fp)
				GameResult = 2;
			} else if (Direction_1 == 11 && Direction_2 == 14) { //--------------------left - right
				GameResult = 3;
			} else if (Direction_1 == 13 && Direction_2 == 11) { //--------------------center - left
				GameResult = 4;
			} else if (Direction_1 == 13 && Direction_2 == 13) { //--------------------center - center
   8826c:	00002306 	br	882fc <main+0x2a0>
				GameResult = 5; //-----------------------------------------------------Save the goal
			} else if (Direction_1 == 13 && Direction_2 == 14) { //--------------------center - right
   88270:	e0bffb17 	ldw	r2,-20(fp)
   88274:	10800358 	cmpnei	r2,r2,13
   88278:	1000061e 	bne	r2,zero,88294 <main+0x238>
   8827c:	e0bffa17 	ldw	r2,-24(fp)
   88280:	10800398 	cmpnei	r2,r2,14
   88284:	1000031e 	bne	r2,zero,88294 <main+0x238>
				GameResult = 6;
   88288:	00800184 	movi	r2,6
   8828c:	e0bff915 	stw	r2,-28(fp)
				GameResult = 3;
			} else if (Direction_1 == 13 && Direction_2 == 11) { //--------------------center - left
				GameResult = 4;
			} else if (Direction_1 == 13 && Direction_2 == 13) { //--------------------center - center
				GameResult = 5; //-----------------------------------------------------Save the goal
			} else if (Direction_1 == 13 && Direction_2 == 14) { //--------------------center - right
   88290:	00001a06 	br	882fc <main+0x2a0>
				GameResult = 6;
			} else if (Direction_1 == 14 && Direction_2 == 11) { //--------------------right - left
   88294:	e0bffb17 	ldw	r2,-20(fp)
   88298:	10800398 	cmpnei	r2,r2,14
   8829c:	1000061e 	bne	r2,zero,882b8 <main+0x25c>
   882a0:	e0bffa17 	ldw	r2,-24(fp)
   882a4:	108002d8 	cmpnei	r2,r2,11
   882a8:	1000031e 	bne	r2,zero,882b8 <main+0x25c>
				GameResult = 7;
   882ac:	008001c4 	movi	r2,7
   882b0:	e0bff915 	stw	r2,-28(fp)
				GameResult = 4;
			} else if (Direction_1 == 13 && Direction_2 == 13) { //--------------------center - center
				GameResult = 5; //-----------------------------------------------------Save the goal
			} else if (Direction_1 == 13 && Direction_2 == 14) { //--------------------center - right
				GameResult = 6;
			} else if (Direction_1 == 14 && Direction_2 == 11) { //--------------------right - left
   882b4:	00001106 	br	882fc <main+0x2a0>
				GameResult = 7;
			} else if (Direction_1 == 14 && Direction_2 == 13) { //--------------------right  - center
   882b8:	e0bffb17 	ldw	r2,-20(fp)
   882bc:	10800398 	cmpnei	r2,r2,14
   882c0:	1000061e 	bne	r2,zero,882dc <main+0x280>
   882c4:	e0bffa17 	ldw	r2,-24(fp)
   882c8:	10800358 	cmpnei	r2,r2,13
   882cc:	1000031e 	bne	r2,zero,882dc <main+0x280>
				GameResult = 8;
   882d0:	00800204 	movi	r2,8
   882d4:	e0bff915 	stw	r2,-28(fp)
				GameResult = 5; //-----------------------------------------------------Save the goal
			} else if (Direction_1 == 13 && Direction_2 == 14) { //--------------------center - right
				GameResult = 6;
			} else if (Direction_1 == 14 && Direction_2 == 11) { //--------------------right - left
				GameResult = 7;
			} else if (Direction_1 == 14 && Direction_2 == 13) { //--------------------right  - center
   882d8:	00000806 	br	882fc <main+0x2a0>
				GameResult = 8;
			} else if (Direction_1 == 14 && Direction_2 == 14) { //--------------------right - right
   882dc:	e0bffb17 	ldw	r2,-20(fp)
   882e0:	10800398 	cmpnei	r2,r2,14
   882e4:	1000051e 	bne	r2,zero,882fc <main+0x2a0>
   882e8:	e0bffa17 	ldw	r2,-24(fp)
   882ec:	10800398 	cmpnei	r2,r2,14
   882f0:	1000021e 	bne	r2,zero,882fc <main+0x2a0>
				GameResult = 9; //-----------------------------------------------------Save the goal
   882f4:	00800244 	movi	r2,9
   882f8:	e0bff915 	stw	r2,-28(fp)
			/*
			 * Play the Anim Base on the value for GameResult.
			 * when two values are equal, the goal keeper save the goal,
			 * else the penalty take the score.
			 */
			AnimPlay(GameResult);
   882fc:	e13ff917 	ldw	r4,-28(fp)
   88300:	00885680 	call	88568 <AnimPlay>
			usleep(2000000);
   88304:	010007f4 	movhi	r4,31
   88308:	21212004 	addi	r4,r4,-31616
   8830c:	00891c00 	call	891c0 <usleep>
			GameState = 4; //----------------------------------------------------------Go to the state for playing Anim.
   88310:	00800104 	movi	r2,4
   88314:	e0bfff15 	stw	r2,-4(fp)
				Dir_temp_2 = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE); //--------------Read the Input from key, and store the value in Direction_2.
			}
			GameState = 3; //-----------------------------------------------------------Enter State 3, for result computation
		}
/*############################################################## STATE 3 ##################################################################*/
		while (GameState == 3) { //-----------------------------------------------------State for compute the result for game.
   88318:	e0bfff17 	ldw	r2,-4(fp)
   8831c:	108000e0 	cmpeqi	r2,r2,3
   88320:	103fa51e 	bne	r2,zero,881b8 <main+0x15c>
			AnimPlay(GameResult);
			usleep(2000000);
			GameState = 4; //----------------------------------------------------------Go to the state for playing Anim.
		}
/*############################################################## STATE 4 ##################################################################*/
		while (GameState == 4) { //----------------------------------------------------State for Anim playing.
   88324:	00002006 	br	883a8 <main+0x34c>
			if (GameResult == 1 || GameResult == 5 || GameResult == 9) { //------------Store the score in either Score1 and Score2
   88328:	e0bff917 	ldw	r2,-28(fp)
   8832c:	10800060 	cmpeqi	r2,r2,1
   88330:	1000061e 	bne	r2,zero,8834c <main+0x2f0>
   88334:	e0bff917 	ldw	r2,-28(fp)
   88338:	10800160 	cmpeqi	r2,r2,5
   8833c:	1000031e 	bne	r2,zero,8834c <main+0x2f0>
   88340:	e0bff917 	ldw	r2,-28(fp)
   88344:	10800258 	cmpnei	r2,r2,9
   88348:	1000041e 	bne	r2,zero,8835c <main+0x300>
				Score_2++; //----------------------------------------------------------The keeper take score
   8834c:	e0bffc17 	ldw	r2,-16(fp)
   88350:	10800044 	addi	r2,r2,1
   88354:	e0bffc15 	stw	r2,-16(fp)
			usleep(2000000);
			GameState = 4; //----------------------------------------------------------Go to the state for playing Anim.
		}
/*############################################################## STATE 4 ##################################################################*/
		while (GameState == 4) { //----------------------------------------------------State for Anim playing.
			if (GameResult == 1 || GameResult == 5 || GameResult == 9) { //------------Store the score in either Score1 and Score2
   88358:	00000306 	br	88368 <main+0x30c>
				Score_2++; //----------------------------------------------------------The keeper take score
			} else {
				Score_1++; //----------------------------------------------------------The taker take score
   8835c:	e0bffd17 	ldw	r2,-12(fp)
   88360:	10800044 	addi	r2,r2,1
   88364:	e0bffd15 	stw	r2,-12(fp)
			}
			// Update the Score on screen
			/* If Round value larger or equal than 5, enter the EXIT Game state.
			 * If Round value smaller then 5, then Enter the State for the first player to choose direction.
			 */
			if (Round < 5) {
   88368:	e0bffe17 	ldw	r2,-8(fp)
   8836c:	10800148 	cmpgei	r2,r2,5
   88370:	1000061e 	bne	r2,zero,8838c <main+0x330>
				GameState = 1;
   88374:	00800044 	movi	r2,1
   88378:	e0bfff15 	stw	r2,-4(fp)
				Round = Round + 1; //-------------------------------------------------Update the Round value
   8837c:	e0bffe17 	ldw	r2,-8(fp)
   88380:	10800044 	addi	r2,r2,1
   88384:	e0bffe15 	stw	r2,-8(fp)
   88388:	00000706 	br	883a8 <main+0x34c>
			} else if (Round >= 5) {
   8838c:	e0bffe17 	ldw	r2,-8(fp)
   88390:	10800150 	cmplti	r2,r2,5
   88394:	1000041e 	bne	r2,zero,883a8 <main+0x34c>
				GameState = 5;
   88398:	00800144 	movi	r2,5
   8839c:	e0bfff15 	stw	r2,-4(fp)
				Round = 1;
   883a0:	00800044 	movi	r2,1
   883a4:	e0bffe15 	stw	r2,-8(fp)
			AnimPlay(GameResult);
			usleep(2000000);
			GameState = 4; //----------------------------------------------------------Go to the state for playing Anim.
		}
/*############################################################## STATE 4 ##################################################################*/
		while (GameState == 4) { //----------------------------------------------------State for Anim playing.
   883a8:	e0bfff17 	ldw	r2,-4(fp)
   883ac:	10800120 	cmpeqi	r2,r2,4
   883b0:	103fdd1e 	bne	r2,zero,88328 <main+0x2cc>
				GameState = 5;
				Round = 1;
			}
		}
/*############################################################## STATE 5 ##################################################################*/
		while (GameState == 5) { //---------------------------------------------------State for Exit the game and reset all data.
   883b4:	00000f06 	br	883f4 <main+0x398>
			int WhoWin; //------------------------------------------------------------------0 for keeper win, 1 for taker win.
			if (Score_1 > Score_2) { //-----------------------------------------------Compare the value for Score_1 and Score_2, the larger one wins. Store value in WhoWin.
   883b8:	e0fffd17 	ldw	r3,-12(fp)
   883bc:	e0bffc17 	ldw	r2,-16(fp)
   883c0:	10c0030e 	bge	r2,r3,883d0 <main+0x374>
				WhoWin = 1;
   883c4:	00800044 	movi	r2,1
   883c8:	e0bff515 	stw	r2,-44(fp)
   883cc:	00000406 	br	883e0 <main+0x384>
			} else if (Score_1 < Score_2) {
   883d0:	e0fffd17 	ldw	r3,-12(fp)
   883d4:	e0bffc17 	ldw	r2,-16(fp)
   883d8:	1880010e 	bge	r3,r2,883e0 <main+0x384>
				WhoWin = 0;
   883dc:	e03ff515 	stw	zero,-44(fp)
			}
			// Display the message 'XXX WIN!!!', 'Game END!!!' base on the value of WhoWin.
			alt_up_pixel_buffer_dma_clear_screen(EnableDev, 0); //-------------------Clean the Screen
   883e0:	e13ff817 	ldw	r4,-32(fp)
   883e4:	000b883a 	mov	r5,zero
   883e8:	00899a00 	call	899a0 <alt_up_pixel_buffer_dma_clear_screen>
			GameState = 6;
   883ec:	00800184 	movi	r2,6
   883f0:	e0bfff15 	stw	r2,-4(fp)
				GameState = 5;
				Round = 1;
			}
		}
/*############################################################## STATE 5 ##################################################################*/
		while (GameState == 5) { //---------------------------------------------------State for Exit the game and reset all data.
   883f4:	e0bfff17 	ldw	r2,-4(fp)
   883f8:	10800160 	cmpeqi	r2,r2,5
   883fc:	103fee1e 	bne	r2,zero,883b8 <main+0x35c>
			}
			// Display the message 'XXX WIN!!!', 'Game END!!!' base on the value of WhoWin.
			alt_up_pixel_buffer_dma_clear_screen(EnableDev, 0); //-------------------Clean the Screen
			GameState = 6;
		}
		while (GameState == 6) { //--------------------------------------------------State for waiting. Wither keep waiting or start the exit game.
   88400:	00001206 	br	8844c <main+0x3f0>
			// Display 'Press KeyX to start new game'
			int Restart = 0;
   88404:	e03ff415 	stw	zero,-48(fp)
			int Restart_tmp = Restart; //------------------------------------------------Read the value for KeyX
   88408:	e0bff417 	ldw	r2,-48(fp)
   8840c:	e0bff315 	stw	r2,-52(fp)
			while (Restart_tmp == Restart) {
   88410:	00000406 	br	88424 <main+0x3c8>
				Restart = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE);
   88414:	00800274 	movhi	r2,9
   88418:	10840004 	addi	r2,r2,4096
   8841c:	10800037 	ldwio	r2,0(r2)
   88420:	e0bff415 	stw	r2,-48(fp)
		}
		while (GameState == 6) { //--------------------------------------------------State for waiting. Wither keep waiting or start the exit game.
			// Display 'Press KeyX to start new game'
			int Restart = 0;
			int Restart_tmp = Restart; //------------------------------------------------Read the value for KeyX
			while (Restart_tmp == Restart) {
   88424:	e0fff317 	ldw	r3,-52(fp)
   88428:	e0bff417 	ldw	r2,-48(fp)
   8842c:	18bff926 	beq	r3,r2,88414 <main+0x3b8>
				Restart = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE);
			}
			if (Restart == 7) {
   88430:	e0bff417 	ldw	r2,-48(fp)
   88434:	108001d8 	cmpnei	r2,r2,7
   88438:	1000021e 	bne	r2,zero,88444 <main+0x3e8>
				GameState = 0; //----------------------------------------------------Enter State 0 for start new game, or stay in Idle.
   8843c:	e03fff15 	stw	zero,-4(fp)
   88440:	00000206 	br	8844c <main+0x3f0>
			} else {
				GameState = 6;
   88444:	00800184 	movi	r2,6
   88448:	e0bfff15 	stw	r2,-4(fp)
			}
			// Display the message 'XXX WIN!!!', 'Game END!!!' base on the value of WhoWin.
			alt_up_pixel_buffer_dma_clear_screen(EnableDev, 0); //-------------------Clean the Screen
			GameState = 6;
		}
		while (GameState == 6) { //--------------------------------------------------State for waiting. Wither keep waiting or start the exit game.
   8844c:	e0bfff17 	ldw	r2,-4(fp)
   88450:	108001a0 	cmpeqi	r2,r2,6
   88454:	103feb1e 	bne	r2,zero,88404 <main+0x3a8>
				GameState = 0; //----------------------------------------------------Enter State 0 for start new game, or stay in Idle.
			} else {
				GameState = 6;
			}
		}
	}
   88458:	003f1f06 	br	880d8 <main+0x7c>

0008845c <initialPic>:
}
/*############################################################## FUNCTIONS ##################################################################*/
void initialPic(void) {
   8845c:	defffa04 	addi	sp,sp,-24
   88460:	dfc00515 	stw	ra,20(sp)
   88464:	df000415 	stw	fp,16(sp)
   88468:	df000404 	addi	fp,sp,16
	alt_up_pixel_buffer_dma_dev* EnableDev;
	EnableDev = alt_up_pixel_buffer_dma_open_dev("/dev/Pixel_Buffer_DMA"); //Enable the VGA Device
   8846c:	01000274 	movhi	r4,9
   88470:	212d8304 	addi	r4,r4,-18932
   88474:	00896dc0 	call	896dc <alt_up_pixel_buffer_dma_open_dev>
   88478:	e0bfff15 	stw	r2,-4(fp)
	alt_up_pixel_buffer_dma_draw_hline(EnableDev, 120, 200, 50, 0XFFFF, 0);
   8847c:	00bfffd4 	movui	r2,65535
   88480:	d8800015 	stw	r2,0(sp)
   88484:	d8000115 	stw	zero,4(sp)
   88488:	e13fff17 	ldw	r4,-4(fp)
   8848c:	01401e04 	movi	r5,120
   88490:	01803204 	movi	r6,200
   88494:	01c00c84 	movi	r7,50
   88498:	0089ff80 	call	89ff8 <alt_up_pixel_buffer_dma_draw_hline>
	alt_up_pixel_buffer_dma_draw_vline(EnableDev, 120, 50, 70, 0XFFFF, 0);
   8849c:	00bfffd4 	movui	r2,65535
   884a0:	d8800015 	stw	r2,0(sp)
   884a4:	d8000115 	stw	zero,4(sp)
   884a8:	e13fff17 	ldw	r4,-4(fp)
   884ac:	01401e04 	movi	r5,120
   884b0:	01800c84 	movi	r6,50
   884b4:	01c01184 	movi	r7,70
   884b8:	008a3480 	call	8a348 <alt_up_pixel_buffer_dma_draw_vline>
	alt_up_pixel_buffer_dma_draw_vline(EnableDev, 200, 50, 70, 0XFFFF, 0);
   884bc:	00bfffd4 	movui	r2,65535
   884c0:	d8800015 	stw	r2,0(sp)
   884c4:	d8000115 	stw	zero,4(sp)
   884c8:	e13fff17 	ldw	r4,-4(fp)
   884cc:	01403204 	movi	r5,200
   884d0:	01800c84 	movi	r6,50
   884d4:	01c01184 	movi	r7,70
   884d8:	008a3480 	call	8a348 <alt_up_pixel_buffer_dma_draw_vline>
	alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 155, 57, 165, 67, 0XFFFF,0); // keeper
   884dc:	008010c4 	movi	r2,67
   884e0:	d8800015 	stw	r2,0(sp)
   884e4:	00bfffd4 	movui	r2,65535
   884e8:	d8800115 	stw	r2,4(sp)
   884ec:	d8000215 	stw	zero,8(sp)
   884f0:	e13fff17 	ldw	r4,-4(fp)
   884f4:	014026c4 	movi	r5,155
   884f8:	01800e44 	movi	r6,57
   884fc:	01c02944 	movi	r7,165
   88500:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
	alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 155, 175, 165, 185,0XFFFF, 0); // taker
   88504:	00802e44 	movi	r2,185
   88508:	d8800015 	stw	r2,0(sp)
   8850c:	00bfffd4 	movui	r2,65535
   88510:	d8800115 	stw	r2,4(sp)
   88514:	d8000215 	stw	zero,8(sp)
   88518:	e13fff17 	ldw	r4,-4(fp)
   8851c:	014026c4 	movi	r5,155
   88520:	01802bc4 	movi	r6,175
   88524:	01c02944 	movi	r7,165
   88528:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
	alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 159, 170, 161, 172,0XFFFF, 0); // Ball
   8852c:	00802b04 	movi	r2,172
   88530:	d8800015 	stw	r2,0(sp)
   88534:	00bfffd4 	movui	r2,65535
   88538:	d8800115 	stw	r2,4(sp)
   8853c:	d8000215 	stw	zero,8(sp)
   88540:	e13fff17 	ldw	r4,-4(fp)
   88544:	014027c4 	movi	r5,159
   88548:	01802a84 	movi	r6,170
   8854c:	01c02844 	movi	r7,161
   88550:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
}
   88554:	e037883a 	mov	sp,fp
   88558:	dfc00117 	ldw	ra,4(sp)
   8855c:	df000017 	ldw	fp,0(sp)
   88560:	dec00204 	addi	sp,sp,8
   88564:	f800283a 	ret

00088568 <AnimPlay>:

void AnimPlay(int Result) {
   88568:	defff504 	addi	sp,sp,-44
   8856c:	dfc00a15 	stw	ra,40(sp)
   88570:	df000915 	stw	fp,36(sp)
   88574:	df000904 	addi	fp,sp,36
   88578:	e13fff15 	stw	r4,-4(fp)
	alt_up_pixel_buffer_dma_dev* EnableDev;
	EnableDev = alt_up_pixel_buffer_dma_open_dev("/dev/Pixel_Buffer_DMA"); //Enable the VGA Device
   8857c:	01000274 	movhi	r4,9
   88580:	212d8304 	addi	r4,r4,-18932
   88584:	00896dc0 	call	896dc <alt_up_pixel_buffer_dma_open_dev>
   88588:	e0bffe15 	stw	r2,-8(fp)
	alt_up_pixel_buffer_dma_clear_screen(EnableDev, 0); //Clean the Screen
   8858c:	e13ffe17 	ldw	r4,-8(fp)
   88590:	000b883a 	mov	r5,zero
   88594:	00899a00 	call	899a0 <alt_up_pixel_buffer_dma_clear_screen>
	alt_up_pixel_buffer_dma_draw_hline(EnableDev, 120, 200, 50, 0XFFFF, 0);
   88598:	00bfffd4 	movui	r2,65535
   8859c:	d8800015 	stw	r2,0(sp)
   885a0:	d8000115 	stw	zero,4(sp)
   885a4:	e13ffe17 	ldw	r4,-8(fp)
   885a8:	01401e04 	movi	r5,120
   885ac:	01803204 	movi	r6,200
   885b0:	01c00c84 	movi	r7,50
   885b4:	0089ff80 	call	89ff8 <alt_up_pixel_buffer_dma_draw_hline>
	alt_up_pixel_buffer_dma_draw_vline(EnableDev, 120, 50, 70, 0XFFFF, 0);
   885b8:	00bfffd4 	movui	r2,65535
   885bc:	d8800015 	stw	r2,0(sp)
   885c0:	d8000115 	stw	zero,4(sp)
   885c4:	e13ffe17 	ldw	r4,-8(fp)
   885c8:	01401e04 	movi	r5,120
   885cc:	01800c84 	movi	r6,50
   885d0:	01c01184 	movi	r7,70
   885d4:	008a3480 	call	8a348 <alt_up_pixel_buffer_dma_draw_vline>
	alt_up_pixel_buffer_dma_draw_vline(EnableDev, 200, 50, 70, 0XFFFF, 0);
   885d8:	00bfffd4 	movui	r2,65535
   885dc:	d8800015 	stw	r2,0(sp)
   885e0:	d8000115 	stw	zero,4(sp)
   885e4:	e13ffe17 	ldw	r4,-8(fp)
   885e8:	01403204 	movi	r5,200
   885ec:	01800c84 	movi	r6,50
   885f0:	01c01184 	movi	r7,70
   885f4:	008a3480 	call	8a348 <alt_up_pixel_buffer_dma_draw_vline>
	alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 155, 57, 165, 67, 0XFFFF,0); // keeper
   885f8:	008010c4 	movi	r2,67
   885fc:	d8800015 	stw	r2,0(sp)
   88600:	00bfffd4 	movui	r2,65535
   88604:	d8800115 	stw	r2,4(sp)
   88608:	d8000215 	stw	zero,8(sp)
   8860c:	e13ffe17 	ldw	r4,-8(fp)
   88610:	014026c4 	movi	r5,155
   88614:	01800e44 	movi	r6,57
   88618:	01c02944 	movi	r7,165
   8861c:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
	alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 155, 175, 165, 185,0XFFFF, 0); // taker
   88620:	00802e44 	movi	r2,185
   88624:	d8800015 	stw	r2,0(sp)
   88628:	00bfffd4 	movui	r2,65535
   8862c:	d8800115 	stw	r2,4(sp)
   88630:	d8000215 	stw	zero,8(sp)
   88634:	e13ffe17 	ldw	r4,-8(fp)
   88638:	014026c4 	movi	r5,155
   8863c:	01802bc4 	movi	r6,175
   88640:	01c02944 	movi	r7,165
   88644:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
	alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 159, 170, 161, 172,0XFFFF, 0); // Ball
   88648:	00802b04 	movi	r2,172
   8864c:	d8800015 	stw	r2,0(sp)
   88650:	00bfffd4 	movui	r2,65535
   88654:	d8800115 	stw	r2,4(sp)
   88658:	d8000215 	stw	zero,8(sp)
   8865c:	e13ffe17 	ldw	r4,-8(fp)
   88660:	014027c4 	movi	r5,159
   88664:	01802a84 	movi	r6,170
   88668:	01c02844 	movi	r7,161
   8866c:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
	int y1 = 170;
   88670:	00802a84 	movi	r2,170
   88674:	e0bffd15 	stw	r2,-12(fp)
	int y2 = 172;
   88678:	00802b04 	movi	r2,172
   8867c:	e0bffc15 	stw	r2,-16(fp)
	int x1 = 159;
   88680:	008027c4 	movi	r2,159
   88684:	e0bffb15 	stw	r2,-20(fp)
	int x2 = 161;
   88688:	00802844 	movi	r2,161
   8868c:	e0bffa15 	stw	r2,-24(fp)
	if (Result == 1){ //left - left
   88690:	e0bfff17 	ldw	r2,-4(fp)
   88694:	10800058 	cmpnei	r2,r2,1
   88698:	10004e1e 	bne	r2,zero,887d4 <AnimPlay+0x26c>
		while (y1 >= 65 && y2 >= 67) {
   8869c:	00003d06 	br	88794 <AnimPlay+0x22c>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0XFFFF, 0); // Ball
   886a0:	e0bffc17 	ldw	r2,-16(fp)
   886a4:	d8800015 	stw	r2,0(sp)
   886a8:	00bfffd4 	movui	r2,65535
   886ac:	d8800115 	stw	r2,4(sp)
   886b0:	d8000215 	stw	zero,8(sp)
   886b4:	e13ffe17 	ldw	r4,-8(fp)
   886b8:	e17ffb17 	ldw	r5,-20(fp)
   886bc:	e1bffd17 	ldw	r6,-12(fp)
   886c0:	e1fffa17 	ldw	r7,-24(fp)
   886c4:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			usleep(25000);
   886c8:	01186a04 	movi	r4,25000
   886cc:	00891c00 	call	891c0 <usleep>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0X0000, 0); // Ball
   886d0:	e0bffc17 	ldw	r2,-16(fp)
   886d4:	d8800015 	stw	r2,0(sp)
   886d8:	d8000115 	stw	zero,4(sp)
   886dc:	d8000215 	stw	zero,8(sp)
   886e0:	e13ffe17 	ldw	r4,-8(fp)
   886e4:	e17ffb17 	ldw	r5,-20(fp)
   886e8:	e1bffd17 	ldw	r6,-12(fp)
   886ec:	e1fffa17 	ldw	r7,-24(fp)
   886f0:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			if (x1 >= 132 && x2 >= 135) {
   886f4:	e0bffb17 	ldw	r2,-20(fp)
   886f8:	10802110 	cmplti	r2,r2,132
   886fc:	1000091e 	bne	r2,zero,88724 <AnimPlay+0x1bc>
   88700:	e0bffa17 	ldw	r2,-24(fp)
   88704:	108021d0 	cmplti	r2,r2,135
   88708:	1000061e 	bne	r2,zero,88724 <AnimPlay+0x1bc>
				x1 = x1 - 1;x2 = x2 - 1;
   8870c:	e0bffb17 	ldw	r2,-20(fp)
   88710:	10bfffc4 	addi	r2,r2,-1
   88714:	e0bffb15 	stw	r2,-20(fp)
   88718:	e0bffa17 	ldw	r2,-24(fp)
   8871c:	10bfffc4 	addi	r2,r2,-1
   88720:	e0bffa15 	stw	r2,-24(fp)
			}
			y1 = y1 - 4;y2 = y2 - 4;
   88724:	e0bffd17 	ldw	r2,-12(fp)
   88728:	10bfff04 	addi	r2,r2,-4
   8872c:	e0bffd15 	stw	r2,-12(fp)
   88730:	e0bffc17 	ldw	r2,-16(fp)
   88734:	10bfff04 	addi	r2,r2,-4
   88738:	e0bffc15 	stw	r2,-16(fp)
			if (y1 <= 80) {
   8873c:	e0bffd17 	ldw	r2,-12(fp)
   88740:	10801448 	cmpgei	r2,r2,81
   88744:	1000131e 	bne	r2,zero,88794 <AnimPlay+0x22c>
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 155, 57, 165,67, 0X0000, 0); // keeper
   88748:	008010c4 	movi	r2,67
   8874c:	d8800015 	stw	r2,0(sp)
   88750:	d8000115 	stw	zero,4(sp)
   88754:	d8000215 	stw	zero,8(sp)
   88758:	e13ffe17 	ldw	r4,-8(fp)
   8875c:	014026c4 	movi	r5,155
   88760:	01800e44 	movi	r6,57
   88764:	01c02944 	movi	r7,165
   88768:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 125, 57, 135,67, 0XFFFF, 0); // keeper
   8876c:	008010c4 	movi	r2,67
   88770:	d8800015 	stw	r2,0(sp)
   88774:	00bfffd4 	movui	r2,65535
   88778:	d8800115 	stw	r2,4(sp)
   8877c:	d8000215 	stw	zero,8(sp)
   88780:	e13ffe17 	ldw	r4,-8(fp)
   88784:	01401f44 	movi	r5,125
   88788:	01800e44 	movi	r6,57
   8878c:	01c021c4 	movi	r7,135
   88790:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
	int y1 = 170;
	int y2 = 172;
	int x1 = 159;
	int x2 = 161;
	if (Result == 1){ //left - left
		while (y1 >= 65 && y2 >= 67) {
   88794:	e0bffd17 	ldw	r2,-12(fp)
   88798:	10801050 	cmplti	r2,r2,65
   8879c:	1000031e 	bne	r2,zero,887ac <AnimPlay+0x244>
   887a0:	e0bffc17 	ldw	r2,-16(fp)
   887a4:	108010c8 	cmpgei	r2,r2,67
   887a8:	103fbd1e 	bne	r2,zero,886a0 <AnimPlay+0x138>
			if (y1 <= 80) {
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 155, 57, 165,67, 0X0000, 0); // keeper
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 125, 57, 135,67, 0XFFFF, 0); // keeper
			}
		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 133, 68, 135, 70,
   887ac:	00801184 	movi	r2,70
   887b0:	d8800015 	stw	r2,0(sp)
   887b4:	00bfffd4 	movui	r2,65535
   887b8:	d8800115 	stw	r2,4(sp)
   887bc:	d8000215 	stw	zero,8(sp)
   887c0:	e13ffe17 	ldw	r4,-8(fp)
   887c4:	01402144 	movi	r5,133
   887c8:	01801104 	movi	r6,68
   887cc:	01c021c4 	movi	r7,135
   887d0:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
				0XFFFF, 0); // Ball
	}
	if (Result == 2){ //left - center
   887d4:	e0bfff17 	ldw	r2,-4(fp)
   887d8:	10800098 	cmpnei	r2,r2,2
   887dc:	1000381e 	bne	r2,zero,888c0 <AnimPlay+0x358>
		while (y1 >= 65 && y2 >= 67) {
   887e0:	00002706 	br	88880 <AnimPlay+0x318>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0XFFFF, 0); // Ball
   887e4:	e0bffc17 	ldw	r2,-16(fp)
   887e8:	d8800015 	stw	r2,0(sp)
   887ec:	00bfffd4 	movui	r2,65535
   887f0:	d8800115 	stw	r2,4(sp)
   887f4:	d8000215 	stw	zero,8(sp)
   887f8:	e13ffe17 	ldw	r4,-8(fp)
   887fc:	e17ffb17 	ldw	r5,-20(fp)
   88800:	e1bffd17 	ldw	r6,-12(fp)
   88804:	e1fffa17 	ldw	r7,-24(fp)
   88808:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			usleep(25000);
   8880c:	01186a04 	movi	r4,25000
   88810:	00891c00 	call	891c0 <usleep>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0X0000, 0); // Ball
   88814:	e0bffc17 	ldw	r2,-16(fp)
   88818:	d8800015 	stw	r2,0(sp)
   8881c:	d8000115 	stw	zero,4(sp)
   88820:	d8000215 	stw	zero,8(sp)
   88824:	e13ffe17 	ldw	r4,-8(fp)
   88828:	e17ffb17 	ldw	r5,-20(fp)
   8882c:	e1bffd17 	ldw	r6,-12(fp)
   88830:	e1fffa17 	ldw	r7,-24(fp)
   88834:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			if (x1 >= 132 && x2 >= 135) {
   88838:	e0bffb17 	ldw	r2,-20(fp)
   8883c:	10802110 	cmplti	r2,r2,132
   88840:	1000091e 	bne	r2,zero,88868 <AnimPlay+0x300>
   88844:	e0bffa17 	ldw	r2,-24(fp)
   88848:	108021d0 	cmplti	r2,r2,135
   8884c:	1000061e 	bne	r2,zero,88868 <AnimPlay+0x300>
				x1 = x1 - 1;x2 = x2 - 1;
   88850:	e0bffb17 	ldw	r2,-20(fp)
   88854:	10bfffc4 	addi	r2,r2,-1
   88858:	e0bffb15 	stw	r2,-20(fp)
   8885c:	e0bffa17 	ldw	r2,-24(fp)
   88860:	10bfffc4 	addi	r2,r2,-1
   88864:	e0bffa15 	stw	r2,-24(fp)
			}
			y1 = y1 - 4;y2 = y2 - 4;
   88868:	e0bffd17 	ldw	r2,-12(fp)
   8886c:	10bfff04 	addi	r2,r2,-4
   88870:	e0bffd15 	stw	r2,-12(fp)
   88874:	e0bffc17 	ldw	r2,-16(fp)
   88878:	10bfff04 	addi	r2,r2,-4
   8887c:	e0bffc15 	stw	r2,-16(fp)
		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 133, 68, 135, 70,
				0XFFFF, 0); // Ball
	}
	if (Result == 2){ //left - center
		while (y1 >= 65 && y2 >= 67) {
   88880:	e0bffd17 	ldw	r2,-12(fp)
   88884:	10801050 	cmplti	r2,r2,65
   88888:	1000031e 	bne	r2,zero,88898 <AnimPlay+0x330>
   8888c:	e0bffc17 	ldw	r2,-16(fp)
   88890:	108010c8 	cmpgei	r2,r2,67
   88894:	103fd31e 	bne	r2,zero,887e4 <AnimPlay+0x27c>
				x1 = x1 - 1;x2 = x2 - 1;
			}
			y1 = y1 - 4;y2 = y2 - 4;

		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 133, 68, 135, 70,
   88898:	00801184 	movi	r2,70
   8889c:	d8800015 	stw	r2,0(sp)
   888a0:	00bfffd4 	movui	r2,65535
   888a4:	d8800115 	stw	r2,4(sp)
   888a8:	d8000215 	stw	zero,8(sp)
   888ac:	e13ffe17 	ldw	r4,-8(fp)
   888b0:	01402144 	movi	r5,133
   888b4:	01801104 	movi	r6,68
   888b8:	01c021c4 	movi	r7,135
   888bc:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
				0XFFFF, 0); // Ball
	}
	if (Result == 3){ //left - right
   888c0:	e0bfff17 	ldw	r2,-4(fp)
   888c4:	108000d8 	cmpnei	r2,r2,3
   888c8:	10004e1e 	bne	r2,zero,88a04 <AnimPlay+0x49c>
		while (y1 >= 65 && y2 >= 67) {
   888cc:	00003d06 	br	889c4 <AnimPlay+0x45c>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0XFFFF, 0); // Ball
   888d0:	e0bffc17 	ldw	r2,-16(fp)
   888d4:	d8800015 	stw	r2,0(sp)
   888d8:	00bfffd4 	movui	r2,65535
   888dc:	d8800115 	stw	r2,4(sp)
   888e0:	d8000215 	stw	zero,8(sp)
   888e4:	e13ffe17 	ldw	r4,-8(fp)
   888e8:	e17ffb17 	ldw	r5,-20(fp)
   888ec:	e1bffd17 	ldw	r6,-12(fp)
   888f0:	e1fffa17 	ldw	r7,-24(fp)
   888f4:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			usleep(25000);
   888f8:	01186a04 	movi	r4,25000
   888fc:	00891c00 	call	891c0 <usleep>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0X0000, 0); // Ball
   88900:	e0bffc17 	ldw	r2,-16(fp)
   88904:	d8800015 	stw	r2,0(sp)
   88908:	d8000115 	stw	zero,4(sp)
   8890c:	d8000215 	stw	zero,8(sp)
   88910:	e13ffe17 	ldw	r4,-8(fp)
   88914:	e17ffb17 	ldw	r5,-20(fp)
   88918:	e1bffd17 	ldw	r6,-12(fp)
   8891c:	e1fffa17 	ldw	r7,-24(fp)
   88920:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			if (x1 >= 132 && x2 >= 135) {
   88924:	e0bffb17 	ldw	r2,-20(fp)
   88928:	10802110 	cmplti	r2,r2,132
   8892c:	1000091e 	bne	r2,zero,88954 <AnimPlay+0x3ec>
   88930:	e0bffa17 	ldw	r2,-24(fp)
   88934:	108021d0 	cmplti	r2,r2,135
   88938:	1000061e 	bne	r2,zero,88954 <AnimPlay+0x3ec>
				x1 = x1 - 1;x2 = x2 - 1;
   8893c:	e0bffb17 	ldw	r2,-20(fp)
   88940:	10bfffc4 	addi	r2,r2,-1
   88944:	e0bffb15 	stw	r2,-20(fp)
   88948:	e0bffa17 	ldw	r2,-24(fp)
   8894c:	10bfffc4 	addi	r2,r2,-1
   88950:	e0bffa15 	stw	r2,-24(fp)
			}
			y1 = y1 - 4;y2 = y2 - 4;
   88954:	e0bffd17 	ldw	r2,-12(fp)
   88958:	10bfff04 	addi	r2,r2,-4
   8895c:	e0bffd15 	stw	r2,-12(fp)
   88960:	e0bffc17 	ldw	r2,-16(fp)
   88964:	10bfff04 	addi	r2,r2,-4
   88968:	e0bffc15 	stw	r2,-16(fp)
			if (y1 <= 80) {
   8896c:	e0bffd17 	ldw	r2,-12(fp)
   88970:	10801448 	cmpgei	r2,r2,81
   88974:	1000131e 	bne	r2,zero,889c4 <AnimPlay+0x45c>
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 155, 57, 165,67, 0X0000, 0); // keeper
   88978:	008010c4 	movi	r2,67
   8897c:	d8800015 	stw	r2,0(sp)
   88980:	d8000115 	stw	zero,4(sp)
   88984:	d8000215 	stw	zero,8(sp)
   88988:	e13ffe17 	ldw	r4,-8(fp)
   8898c:	014026c4 	movi	r5,155
   88990:	01800e44 	movi	r6,57
   88994:	01c02944 	movi	r7,165
   88998:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 195, 57, 185,67, 0XFFFF, 0); // keeper
   8899c:	008010c4 	movi	r2,67
   889a0:	d8800015 	stw	r2,0(sp)
   889a4:	00bfffd4 	movui	r2,65535
   889a8:	d8800115 	stw	r2,4(sp)
   889ac:	d8000215 	stw	zero,8(sp)
   889b0:	e13ffe17 	ldw	r4,-8(fp)
   889b4:	014030c4 	movi	r5,195
   889b8:	01800e44 	movi	r6,57
   889bc:	01c02e44 	movi	r7,185
   889c0:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 133, 68, 135, 70,
				0XFFFF, 0); // Ball
	}
	if (Result == 3){ //left - right
		while (y1 >= 65 && y2 >= 67) {
   889c4:	e0bffd17 	ldw	r2,-12(fp)
   889c8:	10801050 	cmplti	r2,r2,65
   889cc:	1000031e 	bne	r2,zero,889dc <AnimPlay+0x474>
   889d0:	e0bffc17 	ldw	r2,-16(fp)
   889d4:	108010c8 	cmpgei	r2,r2,67
   889d8:	103fbd1e 	bne	r2,zero,888d0 <AnimPlay+0x368>
			if (y1 <= 80) {
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 155, 57, 165,67, 0X0000, 0); // keeper
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 195, 57, 185,67, 0XFFFF, 0); // keeper
			}
		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 133, 68, 135, 70,0XFFFF, 0); // Ball
   889dc:	00801184 	movi	r2,70
   889e0:	d8800015 	stw	r2,0(sp)
   889e4:	00bfffd4 	movui	r2,65535
   889e8:	d8800115 	stw	r2,4(sp)
   889ec:	d8000215 	stw	zero,8(sp)
   889f0:	e13ffe17 	ldw	r4,-8(fp)
   889f4:	01402144 	movi	r5,133
   889f8:	01801104 	movi	r6,68
   889fc:	01c021c4 	movi	r7,135
   88a00:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
	}
	if (Result == 4){ //center - left
   88a04:	e0bfff17 	ldw	r2,-4(fp)
   88a08:	10800118 	cmpnei	r2,r2,4
   88a0c:	1000451e 	bne	r2,zero,88b24 <AnimPlay+0x5bc>
		while (y1 >= 65 && y2 >= 67) {
   88a10:	00003406 	br	88ae4 <AnimPlay+0x57c>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0XFFFF, 0); // Ball
   88a14:	e0bffc17 	ldw	r2,-16(fp)
   88a18:	d8800015 	stw	r2,0(sp)
   88a1c:	00bfffd4 	movui	r2,65535
   88a20:	d8800115 	stw	r2,4(sp)
   88a24:	d8000215 	stw	zero,8(sp)
   88a28:	e13ffe17 	ldw	r4,-8(fp)
   88a2c:	e17ffb17 	ldw	r5,-20(fp)
   88a30:	e1bffd17 	ldw	r6,-12(fp)
   88a34:	e1fffa17 	ldw	r7,-24(fp)
   88a38:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			usleep(25000);
   88a3c:	01186a04 	movi	r4,25000
   88a40:	00891c00 	call	891c0 <usleep>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0X0000, 0); // Ball
   88a44:	e0bffc17 	ldw	r2,-16(fp)
   88a48:	d8800015 	stw	r2,0(sp)
   88a4c:	d8000115 	stw	zero,4(sp)
   88a50:	d8000215 	stw	zero,8(sp)
   88a54:	e13ffe17 	ldw	r4,-8(fp)
   88a58:	e17ffb17 	ldw	r5,-20(fp)
   88a5c:	e1bffd17 	ldw	r6,-12(fp)
   88a60:	e1fffa17 	ldw	r7,-24(fp)
   88a64:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			if (x1 >= 132 && x2 >= 135) {
   88a68:	e0bffb17 	ldw	r2,-20(fp)
   88a6c:	10802110 	cmplti	r2,r2,132
   88a70:	1000001e 	bne	r2,zero,88a74 <AnimPlay+0x50c>
				x1 = x1 - 0;x2 = x2 - 0;
			}
			y1 = y1 - 4;y2 = y2 - 4;
   88a74:	e0bffd17 	ldw	r2,-12(fp)
   88a78:	10bfff04 	addi	r2,r2,-4
   88a7c:	e0bffd15 	stw	r2,-12(fp)
   88a80:	e0bffc17 	ldw	r2,-16(fp)
   88a84:	10bfff04 	addi	r2,r2,-4
   88a88:	e0bffc15 	stw	r2,-16(fp)
			if (y1 <= 80) {
   88a8c:	e0bffd17 	ldw	r2,-12(fp)
   88a90:	10801448 	cmpgei	r2,r2,81
   88a94:	1000131e 	bne	r2,zero,88ae4 <AnimPlay+0x57c>
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 155, 57, 165,67, 0X0000, 0); // keeper
   88a98:	008010c4 	movi	r2,67
   88a9c:	d8800015 	stw	r2,0(sp)
   88aa0:	d8000115 	stw	zero,4(sp)
   88aa4:	d8000215 	stw	zero,8(sp)
   88aa8:	e13ffe17 	ldw	r4,-8(fp)
   88aac:	014026c4 	movi	r5,155
   88ab0:	01800e44 	movi	r6,57
   88ab4:	01c02944 	movi	r7,165
   88ab8:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 125, 57, 135,67, 0XFFFF, 0); // keeper
   88abc:	008010c4 	movi	r2,67
   88ac0:	d8800015 	stw	r2,0(sp)
   88ac4:	00bfffd4 	movui	r2,65535
   88ac8:	d8800115 	stw	r2,4(sp)
   88acc:	d8000215 	stw	zero,8(sp)
   88ad0:	e13ffe17 	ldw	r4,-8(fp)
   88ad4:	01401f44 	movi	r5,125
   88ad8:	01800e44 	movi	r6,57
   88adc:	01c021c4 	movi	r7,135
   88ae0:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			}
		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 133, 68, 135, 70,0XFFFF, 0); // Ball
	}
	if (Result == 4){ //center - left
		while (y1 >= 65 && y2 >= 67) {
   88ae4:	e0bffd17 	ldw	r2,-12(fp)
   88ae8:	10801050 	cmplti	r2,r2,65
   88aec:	1000031e 	bne	r2,zero,88afc <AnimPlay+0x594>
   88af0:	e0bffc17 	ldw	r2,-16(fp)
   88af4:	108010c8 	cmpgei	r2,r2,67
   88af8:	103fc61e 	bne	r2,zero,88a14 <AnimPlay+0x4ac>
			if (y1 <= 80) {
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 155, 57, 165,67, 0X0000, 0); // keeper
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 125, 57, 135,67, 0XFFFF, 0); // keeper
			}
		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,
   88afc:	e0bffc17 	ldw	r2,-16(fp)
   88b00:	d8800015 	stw	r2,0(sp)
   88b04:	00bfffd4 	movui	r2,65535
   88b08:	d8800115 	stw	r2,4(sp)
   88b0c:	d8000215 	stw	zero,8(sp)
   88b10:	e13ffe17 	ldw	r4,-8(fp)
   88b14:	e17ffb17 	ldw	r5,-20(fp)
   88b18:	e1bffd17 	ldw	r6,-12(fp)
   88b1c:	e1fffa17 	ldw	r7,-24(fp)
   88b20:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
				0XFFFF, 0); // Ball
	}
	if (Result == 5){ //center - center
   88b24:	e0bfff17 	ldw	r2,-4(fp)
   88b28:	10800158 	cmpnei	r2,r2,5
   88b2c:	10002f1e 	bne	r2,zero,88bec <AnimPlay+0x684>
		while (y1 >= 65 && y2 >= 67) {
   88b30:	00001e06 	br	88bac <AnimPlay+0x644>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0XFFFF, 0); // Ball
   88b34:	e0bffc17 	ldw	r2,-16(fp)
   88b38:	d8800015 	stw	r2,0(sp)
   88b3c:	00bfffd4 	movui	r2,65535
   88b40:	d8800115 	stw	r2,4(sp)
   88b44:	d8000215 	stw	zero,8(sp)
   88b48:	e13ffe17 	ldw	r4,-8(fp)
   88b4c:	e17ffb17 	ldw	r5,-20(fp)
   88b50:	e1bffd17 	ldw	r6,-12(fp)
   88b54:	e1fffa17 	ldw	r7,-24(fp)
   88b58:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			usleep(25000);
   88b5c:	01186a04 	movi	r4,25000
   88b60:	00891c00 	call	891c0 <usleep>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0X0000, 0); // Ball
   88b64:	e0bffc17 	ldw	r2,-16(fp)
   88b68:	d8800015 	stw	r2,0(sp)
   88b6c:	d8000115 	stw	zero,4(sp)
   88b70:	d8000215 	stw	zero,8(sp)
   88b74:	e13ffe17 	ldw	r4,-8(fp)
   88b78:	e17ffb17 	ldw	r5,-20(fp)
   88b7c:	e1bffd17 	ldw	r6,-12(fp)
   88b80:	e1fffa17 	ldw	r7,-24(fp)
   88b84:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			if (x1 >= 132 && x2 >= 135) {
   88b88:	e0bffb17 	ldw	r2,-20(fp)
   88b8c:	10802110 	cmplti	r2,r2,132
   88b90:	1000001e 	bne	r2,zero,88b94 <AnimPlay+0x62c>
				x1 = x1 - 0;x2 = x2 - 0;
			}
			y1 = y1 - 4;y2 = y2 - 4;
   88b94:	e0bffd17 	ldw	r2,-12(fp)
   88b98:	10bfff04 	addi	r2,r2,-4
   88b9c:	e0bffd15 	stw	r2,-12(fp)
   88ba0:	e0bffc17 	ldw	r2,-16(fp)
   88ba4:	10bfff04 	addi	r2,r2,-4
   88ba8:	e0bffc15 	stw	r2,-16(fp)
		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,
				0XFFFF, 0); // Ball
	}
	if (Result == 5){ //center - center
		while (y1 >= 65 && y2 >= 67) {
   88bac:	e0bffd17 	ldw	r2,-12(fp)
   88bb0:	10801050 	cmplti	r2,r2,65
   88bb4:	1000031e 	bne	r2,zero,88bc4 <AnimPlay+0x65c>
   88bb8:	e0bffc17 	ldw	r2,-16(fp)
   88bbc:	108010c8 	cmpgei	r2,r2,67
   88bc0:	103fdc1e 	bne	r2,zero,88b34 <AnimPlay+0x5cc>
				x1 = x1 - 0;x2 = x2 - 0;
			}
			y1 = y1 - 4;y2 = y2 - 4;

		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0XFFFF, 0); // Ball
   88bc4:	e0bffc17 	ldw	r2,-16(fp)
   88bc8:	d8800015 	stw	r2,0(sp)
   88bcc:	00bfffd4 	movui	r2,65535
   88bd0:	d8800115 	stw	r2,4(sp)
   88bd4:	d8000215 	stw	zero,8(sp)
   88bd8:	e13ffe17 	ldw	r4,-8(fp)
   88bdc:	e17ffb17 	ldw	r5,-20(fp)
   88be0:	e1bffd17 	ldw	r6,-12(fp)
   88be4:	e1fffa17 	ldw	r7,-24(fp)
   88be8:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
	}
	if (Result == 6){ //center - right
   88bec:	e0bfff17 	ldw	r2,-4(fp)
   88bf0:	10800198 	cmpnei	r2,r2,6
   88bf4:	1000451e 	bne	r2,zero,88d0c <AnimPlay+0x7a4>
		while (y1 >= 65 && y2 >= 67) {
   88bf8:	00003406 	br	88ccc <AnimPlay+0x764>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0XFFFF, 0); // Ball
   88bfc:	e0bffc17 	ldw	r2,-16(fp)
   88c00:	d8800015 	stw	r2,0(sp)
   88c04:	00bfffd4 	movui	r2,65535
   88c08:	d8800115 	stw	r2,4(sp)
   88c0c:	d8000215 	stw	zero,8(sp)
   88c10:	e13ffe17 	ldw	r4,-8(fp)
   88c14:	e17ffb17 	ldw	r5,-20(fp)
   88c18:	e1bffd17 	ldw	r6,-12(fp)
   88c1c:	e1fffa17 	ldw	r7,-24(fp)
   88c20:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			usleep(25000);
   88c24:	01186a04 	movi	r4,25000
   88c28:	00891c00 	call	891c0 <usleep>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0X0000, 0); // Ball
   88c2c:	e0bffc17 	ldw	r2,-16(fp)
   88c30:	d8800015 	stw	r2,0(sp)
   88c34:	d8000115 	stw	zero,4(sp)
   88c38:	d8000215 	stw	zero,8(sp)
   88c3c:	e13ffe17 	ldw	r4,-8(fp)
   88c40:	e17ffb17 	ldw	r5,-20(fp)
   88c44:	e1bffd17 	ldw	r6,-12(fp)
   88c48:	e1fffa17 	ldw	r7,-24(fp)
   88c4c:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			if (x1 >= 132 && x2 >= 135) {
   88c50:	e0bffb17 	ldw	r2,-20(fp)
   88c54:	10802110 	cmplti	r2,r2,132
   88c58:	1000001e 	bne	r2,zero,88c5c <AnimPlay+0x6f4>
				x1 = x1 - 0;x2 = x2 - 0;
			}
			y1 = y1 - 4;y2 = y2 - 4;
   88c5c:	e0bffd17 	ldw	r2,-12(fp)
   88c60:	10bfff04 	addi	r2,r2,-4
   88c64:	e0bffd15 	stw	r2,-12(fp)
   88c68:	e0bffc17 	ldw	r2,-16(fp)
   88c6c:	10bfff04 	addi	r2,r2,-4
   88c70:	e0bffc15 	stw	r2,-16(fp)
			if (y1 <= 80) {
   88c74:	e0bffd17 	ldw	r2,-12(fp)
   88c78:	10801448 	cmpgei	r2,r2,81
   88c7c:	1000131e 	bne	r2,zero,88ccc <AnimPlay+0x764>
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 155, 57, 165,67, 0X0000, 0); // keeper
   88c80:	008010c4 	movi	r2,67
   88c84:	d8800015 	stw	r2,0(sp)
   88c88:	d8000115 	stw	zero,4(sp)
   88c8c:	d8000215 	stw	zero,8(sp)
   88c90:	e13ffe17 	ldw	r4,-8(fp)
   88c94:	014026c4 	movi	r5,155
   88c98:	01800e44 	movi	r6,57
   88c9c:	01c02944 	movi	r7,165
   88ca0:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 195, 57, 185,67, 0XFFFF, 0); // keeper
   88ca4:	008010c4 	movi	r2,67
   88ca8:	d8800015 	stw	r2,0(sp)
   88cac:	00bfffd4 	movui	r2,65535
   88cb0:	d8800115 	stw	r2,4(sp)
   88cb4:	d8000215 	stw	zero,8(sp)
   88cb8:	e13ffe17 	ldw	r4,-8(fp)
   88cbc:	014030c4 	movi	r5,195
   88cc0:	01800e44 	movi	r6,57
   88cc4:	01c02e44 	movi	r7,185
   88cc8:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>

		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0XFFFF, 0); // Ball
	}
	if (Result == 6){ //center - right
		while (y1 >= 65 && y2 >= 67) {
   88ccc:	e0bffd17 	ldw	r2,-12(fp)
   88cd0:	10801050 	cmplti	r2,r2,65
   88cd4:	1000031e 	bne	r2,zero,88ce4 <AnimPlay+0x77c>
   88cd8:	e0bffc17 	ldw	r2,-16(fp)
   88cdc:	108010c8 	cmpgei	r2,r2,67
   88ce0:	103fc61e 	bne	r2,zero,88bfc <AnimPlay+0x694>
			if (y1 <= 80) {
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 155, 57, 165,67, 0X0000, 0); // keeper
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 195, 57, 185,67, 0XFFFF, 0); // keeper
			}
		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,
   88ce4:	e0bffc17 	ldw	r2,-16(fp)
   88ce8:	d8800015 	stw	r2,0(sp)
   88cec:	00bfffd4 	movui	r2,65535
   88cf0:	d8800115 	stw	r2,4(sp)
   88cf4:	d8000215 	stw	zero,8(sp)
   88cf8:	e13ffe17 	ldw	r4,-8(fp)
   88cfc:	e17ffb17 	ldw	r5,-20(fp)
   88d00:	e1bffd17 	ldw	r6,-12(fp)
   88d04:	e1fffa17 	ldw	r7,-24(fp)
   88d08:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
				0XFFFF, 0); // Ball
	}
	if (Result == 7){ //right -left
   88d0c:	e0bfff17 	ldw	r2,-4(fp)
   88d10:	108001d8 	cmpnei	r2,r2,7
   88d14:	10004e1e 	bne	r2,zero,88e50 <AnimPlay+0x8e8>
		while (y1 >= 65 && y2 >= 67) {
   88d18:	00003d06 	br	88e10 <AnimPlay+0x8a8>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0XFFFF, 0); // Ball
   88d1c:	e0bffc17 	ldw	r2,-16(fp)
   88d20:	d8800015 	stw	r2,0(sp)
   88d24:	00bfffd4 	movui	r2,65535
   88d28:	d8800115 	stw	r2,4(sp)
   88d2c:	d8000215 	stw	zero,8(sp)
   88d30:	e13ffe17 	ldw	r4,-8(fp)
   88d34:	e17ffb17 	ldw	r5,-20(fp)
   88d38:	e1bffd17 	ldw	r6,-12(fp)
   88d3c:	e1fffa17 	ldw	r7,-24(fp)
   88d40:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			usleep(25000);
   88d44:	01186a04 	movi	r4,25000
   88d48:	00891c00 	call	891c0 <usleep>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0X0000, 0); // Ball
   88d4c:	e0bffc17 	ldw	r2,-16(fp)
   88d50:	d8800015 	stw	r2,0(sp)
   88d54:	d8000115 	stw	zero,4(sp)
   88d58:	d8000215 	stw	zero,8(sp)
   88d5c:	e13ffe17 	ldw	r4,-8(fp)
   88d60:	e17ffb17 	ldw	r5,-20(fp)
   88d64:	e1bffd17 	ldw	r6,-12(fp)
   88d68:	e1fffa17 	ldw	r7,-24(fp)
   88d6c:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			if (x1 >= 132 && x2 >= 135) {
   88d70:	e0bffb17 	ldw	r2,-20(fp)
   88d74:	10802110 	cmplti	r2,r2,132
   88d78:	1000091e 	bne	r2,zero,88da0 <AnimPlay+0x838>
   88d7c:	e0bffa17 	ldw	r2,-24(fp)
   88d80:	108021d0 	cmplti	r2,r2,135
   88d84:	1000061e 	bne	r2,zero,88da0 <AnimPlay+0x838>
				x1 = x1 + 1;x2 = x2 + 1;
   88d88:	e0bffb17 	ldw	r2,-20(fp)
   88d8c:	10800044 	addi	r2,r2,1
   88d90:	e0bffb15 	stw	r2,-20(fp)
   88d94:	e0bffa17 	ldw	r2,-24(fp)
   88d98:	10800044 	addi	r2,r2,1
   88d9c:	e0bffa15 	stw	r2,-24(fp)
			}
			y1 = y1 - 4;y2 = y2 - 4;
   88da0:	e0bffd17 	ldw	r2,-12(fp)
   88da4:	10bfff04 	addi	r2,r2,-4
   88da8:	e0bffd15 	stw	r2,-12(fp)
   88dac:	e0bffc17 	ldw	r2,-16(fp)
   88db0:	10bfff04 	addi	r2,r2,-4
   88db4:	e0bffc15 	stw	r2,-16(fp)
			if (y1 <= 80) {
   88db8:	e0bffd17 	ldw	r2,-12(fp)
   88dbc:	10801448 	cmpgei	r2,r2,81
   88dc0:	1000131e 	bne	r2,zero,88e10 <AnimPlay+0x8a8>
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 155, 57, 165,67, 0X0000, 0); // keeper
   88dc4:	008010c4 	movi	r2,67
   88dc8:	d8800015 	stw	r2,0(sp)
   88dcc:	d8000115 	stw	zero,4(sp)
   88dd0:	d8000215 	stw	zero,8(sp)
   88dd4:	e13ffe17 	ldw	r4,-8(fp)
   88dd8:	014026c4 	movi	r5,155
   88ddc:	01800e44 	movi	r6,57
   88de0:	01c02944 	movi	r7,165
   88de4:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 125, 57, 135,67, 0XFFFF, 0); // keeper
   88de8:	008010c4 	movi	r2,67
   88dec:	d8800015 	stw	r2,0(sp)
   88df0:	00bfffd4 	movui	r2,65535
   88df4:	d8800115 	stw	r2,4(sp)
   88df8:	d8000215 	stw	zero,8(sp)
   88dfc:	e13ffe17 	ldw	r4,-8(fp)
   88e00:	01401f44 	movi	r5,125
   88e04:	01800e44 	movi	r6,57
   88e08:	01c021c4 	movi	r7,135
   88e0c:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,
				0XFFFF, 0); // Ball
	}
	if (Result == 7){ //right -left
		while (y1 >= 65 && y2 >= 67) {
   88e10:	e0bffd17 	ldw	r2,-12(fp)
   88e14:	10801050 	cmplti	r2,r2,65
   88e18:	1000031e 	bne	r2,zero,88e28 <AnimPlay+0x8c0>
   88e1c:	e0bffc17 	ldw	r2,-16(fp)
   88e20:	108010c8 	cmpgei	r2,r2,67
   88e24:	103fbd1e 	bne	r2,zero,88d1c <AnimPlay+0x7b4>
			if (y1 <= 80) {
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 155, 57, 165,67, 0X0000, 0); // keeper
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 125, 57, 135,67, 0XFFFF, 0); // keeper
			}
		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,
   88e28:	e0bffc17 	ldw	r2,-16(fp)
   88e2c:	d8800015 	stw	r2,0(sp)
   88e30:	00bfffd4 	movui	r2,65535
   88e34:	d8800115 	stw	r2,4(sp)
   88e38:	d8000215 	stw	zero,8(sp)
   88e3c:	e13ffe17 	ldw	r4,-8(fp)
   88e40:	e17ffb17 	ldw	r5,-20(fp)
   88e44:	e1bffd17 	ldw	r6,-12(fp)
   88e48:	e1fffa17 	ldw	r7,-24(fp)
   88e4c:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
				0XFFFF, 0); // Ball
	}
	if (Result == 8){ //right -center
   88e50:	e0bfff17 	ldw	r2,-4(fp)
   88e54:	10800218 	cmpnei	r2,r2,8
   88e58:	1000381e 	bne	r2,zero,88f3c <AnimPlay+0x9d4>
		while (y1 >= 65 && y2 >= 67) {
   88e5c:	00002706 	br	88efc <AnimPlay+0x994>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0XFFFF, 0); // Ball
   88e60:	e0bffc17 	ldw	r2,-16(fp)
   88e64:	d8800015 	stw	r2,0(sp)
   88e68:	00bfffd4 	movui	r2,65535
   88e6c:	d8800115 	stw	r2,4(sp)
   88e70:	d8000215 	stw	zero,8(sp)
   88e74:	e13ffe17 	ldw	r4,-8(fp)
   88e78:	e17ffb17 	ldw	r5,-20(fp)
   88e7c:	e1bffd17 	ldw	r6,-12(fp)
   88e80:	e1fffa17 	ldw	r7,-24(fp)
   88e84:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			usleep(25000);
   88e88:	01186a04 	movi	r4,25000
   88e8c:	00891c00 	call	891c0 <usleep>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0X0000, 0); // Ball
   88e90:	e0bffc17 	ldw	r2,-16(fp)
   88e94:	d8800015 	stw	r2,0(sp)
   88e98:	d8000115 	stw	zero,4(sp)
   88e9c:	d8000215 	stw	zero,8(sp)
   88ea0:	e13ffe17 	ldw	r4,-8(fp)
   88ea4:	e17ffb17 	ldw	r5,-20(fp)
   88ea8:	e1bffd17 	ldw	r6,-12(fp)
   88eac:	e1fffa17 	ldw	r7,-24(fp)
   88eb0:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			if (x1 >= 132 && x2 >= 135) {
   88eb4:	e0bffb17 	ldw	r2,-20(fp)
   88eb8:	10802110 	cmplti	r2,r2,132
   88ebc:	1000091e 	bne	r2,zero,88ee4 <AnimPlay+0x97c>
   88ec0:	e0bffa17 	ldw	r2,-24(fp)
   88ec4:	108021d0 	cmplti	r2,r2,135
   88ec8:	1000061e 	bne	r2,zero,88ee4 <AnimPlay+0x97c>
				x1 = x1 + 1;x2 = x2 + 1;
   88ecc:	e0bffb17 	ldw	r2,-20(fp)
   88ed0:	10800044 	addi	r2,r2,1
   88ed4:	e0bffb15 	stw	r2,-20(fp)
   88ed8:	e0bffa17 	ldw	r2,-24(fp)
   88edc:	10800044 	addi	r2,r2,1
   88ee0:	e0bffa15 	stw	r2,-24(fp)
			}
			y1 = y1 - 4;y2 = y2 - 4;
   88ee4:	e0bffd17 	ldw	r2,-12(fp)
   88ee8:	10bfff04 	addi	r2,r2,-4
   88eec:	e0bffd15 	stw	r2,-12(fp)
   88ef0:	e0bffc17 	ldw	r2,-16(fp)
   88ef4:	10bfff04 	addi	r2,r2,-4
   88ef8:	e0bffc15 	stw	r2,-16(fp)
		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,
				0XFFFF, 0); // Ball
	}
	if (Result == 8){ //right -center
		while (y1 >= 65 && y2 >= 67) {
   88efc:	e0bffd17 	ldw	r2,-12(fp)
   88f00:	10801050 	cmplti	r2,r2,65
   88f04:	1000031e 	bne	r2,zero,88f14 <AnimPlay+0x9ac>
   88f08:	e0bffc17 	ldw	r2,-16(fp)
   88f0c:	108010c8 	cmpgei	r2,r2,67
   88f10:	103fd31e 	bne	r2,zero,88e60 <AnimPlay+0x8f8>
			if (x1 >= 132 && x2 >= 135) {
				x1 = x1 + 1;x2 = x2 + 1;
			}
			y1 = y1 - 4;y2 = y2 - 4;
		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0XFFFF, 0); // Ball
   88f14:	e0bffc17 	ldw	r2,-16(fp)
   88f18:	d8800015 	stw	r2,0(sp)
   88f1c:	00bfffd4 	movui	r2,65535
   88f20:	d8800115 	stw	r2,4(sp)
   88f24:	d8000215 	stw	zero,8(sp)
   88f28:	e13ffe17 	ldw	r4,-8(fp)
   88f2c:	e17ffb17 	ldw	r5,-20(fp)
   88f30:	e1bffd17 	ldw	r6,-12(fp)
   88f34:	e1fffa17 	ldw	r7,-24(fp)
   88f38:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
	}
	if (Result == 9){ //right -right
   88f3c:	e0bfff17 	ldw	r2,-4(fp)
   88f40:	10800258 	cmpnei	r2,r2,9
   88f44:	10004e1e 	bne	r2,zero,89080 <AnimPlay+0xb18>
		while (y1 >= 65 && y2 >= 67) {
   88f48:	00003d06 	br	89040 <AnimPlay+0xad8>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0XFFFF, 0); // Ball
   88f4c:	e0bffc17 	ldw	r2,-16(fp)
   88f50:	d8800015 	stw	r2,0(sp)
   88f54:	00bfffd4 	movui	r2,65535
   88f58:	d8800115 	stw	r2,4(sp)
   88f5c:	d8000215 	stw	zero,8(sp)
   88f60:	e13ffe17 	ldw	r4,-8(fp)
   88f64:	e17ffb17 	ldw	r5,-20(fp)
   88f68:	e1bffd17 	ldw	r6,-12(fp)
   88f6c:	e1fffa17 	ldw	r7,-24(fp)
   88f70:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			usleep(25000);
   88f74:	01186a04 	movi	r4,25000
   88f78:	00891c00 	call	891c0 <usleep>
			alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0X0000, 0); // Ball
   88f7c:	e0bffc17 	ldw	r2,-16(fp)
   88f80:	d8800015 	stw	r2,0(sp)
   88f84:	d8000115 	stw	zero,4(sp)
   88f88:	d8000215 	stw	zero,8(sp)
   88f8c:	e13ffe17 	ldw	r4,-8(fp)
   88f90:	e17ffb17 	ldw	r5,-20(fp)
   88f94:	e1bffd17 	ldw	r6,-12(fp)
   88f98:	e1fffa17 	ldw	r7,-24(fp)
   88f9c:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			if (x1 >= 132 && x2 >= 135) {
   88fa0:	e0bffb17 	ldw	r2,-20(fp)
   88fa4:	10802110 	cmplti	r2,r2,132
   88fa8:	1000091e 	bne	r2,zero,88fd0 <AnimPlay+0xa68>
   88fac:	e0bffa17 	ldw	r2,-24(fp)
   88fb0:	108021d0 	cmplti	r2,r2,135
   88fb4:	1000061e 	bne	r2,zero,88fd0 <AnimPlay+0xa68>
				x1 = x1 + 1;x2 = x2 + 1;
   88fb8:	e0bffb17 	ldw	r2,-20(fp)
   88fbc:	10800044 	addi	r2,r2,1
   88fc0:	e0bffb15 	stw	r2,-20(fp)
   88fc4:	e0bffa17 	ldw	r2,-24(fp)
   88fc8:	10800044 	addi	r2,r2,1
   88fcc:	e0bffa15 	stw	r2,-24(fp)
			}
			y1 = y1 - 4;y2 = y2 - 4;
   88fd0:	e0bffd17 	ldw	r2,-12(fp)
   88fd4:	10bfff04 	addi	r2,r2,-4
   88fd8:	e0bffd15 	stw	r2,-12(fp)
   88fdc:	e0bffc17 	ldw	r2,-16(fp)
   88fe0:	10bfff04 	addi	r2,r2,-4
   88fe4:	e0bffc15 	stw	r2,-16(fp)
			if (y1 <= 80) {
   88fe8:	e0bffd17 	ldw	r2,-12(fp)
   88fec:	10801448 	cmpgei	r2,r2,81
   88ff0:	1000131e 	bne	r2,zero,89040 <AnimPlay+0xad8>
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 155, 57, 165,67, 0X0000, 0); // keeper
   88ff4:	008010c4 	movi	r2,67
   88ff8:	d8800015 	stw	r2,0(sp)
   88ffc:	d8000115 	stw	zero,4(sp)
   89000:	d8000215 	stw	zero,8(sp)
   89004:	e13ffe17 	ldw	r4,-8(fp)
   89008:	014026c4 	movi	r5,155
   8900c:	01800e44 	movi	r6,57
   89010:	01c02944 	movi	r7,165
   89014:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 195, 57, 185,67, 0XFFFF, 0); // keeper
   89018:	008010c4 	movi	r2,67
   8901c:	d8800015 	stw	r2,0(sp)
   89020:	00bfffd4 	movui	r2,65535
   89024:	d8800115 	stw	r2,4(sp)
   89028:	d8000215 	stw	zero,8(sp)
   8902c:	e13ffe17 	ldw	r4,-8(fp)
   89030:	014030c4 	movi	r5,195
   89034:	01800e44 	movi	r6,57
   89038:	01c02e44 	movi	r7,185
   8903c:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
			y1 = y1 - 4;y2 = y2 - 4;
		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0XFFFF, 0); // Ball
	}
	if (Result == 9){ //right -right
		while (y1 >= 65 && y2 >= 67) {
   89040:	e0bffd17 	ldw	r2,-12(fp)
   89044:	10801050 	cmplti	r2,r2,65
   89048:	1000031e 	bne	r2,zero,89058 <AnimPlay+0xaf0>
   8904c:	e0bffc17 	ldw	r2,-16(fp)
   89050:	108010c8 	cmpgei	r2,r2,67
   89054:	103fbd1e 	bne	r2,zero,88f4c <AnimPlay+0x9e4>
			if (y1 <= 80) {
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 155, 57, 165,67, 0X0000, 0); // keeper
				alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, 195, 57, 185,67, 0XFFFF, 0); // keeper
			}
		}
		alt_up_pixel_buffer_dma_draw_rectangle(EnableDev, x1, y1, x2, y2,0XFFFF, 0); // Ball
   89058:	e0bffc17 	ldw	r2,-16(fp)
   8905c:	d8800015 	stw	r2,0(sp)
   89060:	00bfffd4 	movui	r2,65535
   89064:	d8800115 	stw	r2,4(sp)
   89068:	d8000215 	stw	zero,8(sp)
   8906c:	e13ffe17 	ldw	r4,-8(fp)
   89070:	e17ffb17 	ldw	r5,-20(fp)
   89074:	e1bffd17 	ldw	r6,-12(fp)
   89078:	e1fffa17 	ldw	r7,-24(fp)
   8907c:	008a7180 	call	8a718 <alt_up_pixel_buffer_dma_draw_rectangle>
	}
}
   89080:	e037883a 	mov	sp,fp
   89084:	dfc00117 	ldw	ra,4(sp)
   89088:	df000017 	ldw	fp,0(sp)
   8908c:	dec00204 	addi	sp,sp,8
   89090:	f800283a 	ret

00089094 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   89094:	defffe04 	addi	sp,sp,-8
   89098:	dfc00115 	stw	ra,4(sp)
   8909c:	df000015 	stw	fp,0(sp)
   890a0:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
   890a4:	01000274 	movhi	r4,9
   890a8:	212e6104 	addi	r4,r4,-18044
   890ac:	01400274 	movhi	r5,9
   890b0:	296d9704 	addi	r5,r5,-18852
   890b4:	01800274 	movhi	r6,9
   890b8:	31ae6104 	addi	r6,r6,-18044
   890bc:	00891140 	call	89114 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
   890c0:	01000274 	movhi	r4,9
   890c4:	21200804 	addi	r4,r4,-32736
   890c8:	01400274 	movhi	r5,9
   890cc:	29600804 	addi	r5,r5,-32736
   890d0:	01800274 	movhi	r6,9
   890d4:	31a00804 	addi	r6,r6,-32736
   890d8:	00891140 	call	89114 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
   890dc:	01000274 	movhi	r4,9
   890e0:	212d8304 	addi	r4,r4,-18932
   890e4:	01400274 	movhi	r5,9
   890e8:	296d8304 	addi	r5,r5,-18932
   890ec:	01800274 	movhi	r6,9
   890f0:	31ad9704 	addi	r6,r6,-18852
   890f4:	00891140 	call	89114 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   890f8:	008aef00 	call	8aef0 <alt_dcache_flush_all>
  alt_icache_flush_all();
   890fc:	008b0e00 	call	8b0e0 <alt_icache_flush_all>
}
   89100:	e037883a 	mov	sp,fp
   89104:	dfc00117 	ldw	ra,4(sp)
   89108:	df000017 	ldw	fp,0(sp)
   8910c:	dec00204 	addi	sp,sp,8
   89110:	f800283a 	ret

00089114 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
   89114:	defffc04 	addi	sp,sp,-16
   89118:	df000315 	stw	fp,12(sp)
   8911c:	df000304 	addi	fp,sp,12
   89120:	e13ffd15 	stw	r4,-12(fp)
   89124:	e17ffe15 	stw	r5,-8(fp)
   89128:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
   8912c:	e0fffe17 	ldw	r3,-8(fp)
   89130:	e0bffd17 	ldw	r2,-12(fp)
   89134:	18800e26 	beq	r3,r2,89170 <alt_load_section+0x5c>
  {
    while( to != end )
   89138:	00000a06 	br	89164 <alt_load_section+0x50>
    {
      *to++ = *from++;
   8913c:	e0bffd17 	ldw	r2,-12(fp)
   89140:	10c00017 	ldw	r3,0(r2)
   89144:	e0bffe17 	ldw	r2,-8(fp)
   89148:	10c00015 	stw	r3,0(r2)
   8914c:	e0bffe17 	ldw	r2,-8(fp)
   89150:	10800104 	addi	r2,r2,4
   89154:	e0bffe15 	stw	r2,-8(fp)
   89158:	e0bffd17 	ldw	r2,-12(fp)
   8915c:	10800104 	addi	r2,r2,4
   89160:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
   89164:	e0fffe17 	ldw	r3,-8(fp)
   89168:	e0bfff17 	ldw	r2,-4(fp)
   8916c:	18bff31e 	bne	r3,r2,8913c <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
   89170:	e037883a 	mov	sp,fp
   89174:	df000017 	ldw	fp,0(sp)
   89178:	dec00104 	addi	sp,sp,4
   8917c:	f800283a 	ret

00089180 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   89180:	defffd04 	addi	sp,sp,-12
   89184:	dfc00215 	stw	ra,8(sp)
   89188:	df000115 	stw	fp,4(sp)
   8918c:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   89190:	0009883a 	mov	r4,zero
   89194:	00891f00 	call	891f0 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   89198:	00892240 	call	89224 <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
   8919c:	d120d217 	ldw	r4,-31928(gp)
   891a0:	d160d317 	ldw	r5,-31924(gp)
   891a4:	d1a0d417 	ldw	r6,-31920(gp)
   891a8:	008805c0 	call	8805c <main>
   891ac:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
   891b0:	01000044 	movi	r4,1
   891b4:	008ad940 	call	8ad94 <close>
  exit (result);
   891b8:	e13fff17 	ldw	r4,-4(fp)
   891bc:	008b2200 	call	8b220 <exit>

000891c0 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
   891c0:	defffd04 	addi	sp,sp,-12
   891c4:	dfc00215 	stw	ra,8(sp)
   891c8:	df000115 	stw	fp,4(sp)
   891cc:	df000104 	addi	fp,sp,4
   891d0:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
   891d4:	e13fff17 	ldw	r4,-4(fp)
   891d8:	008ac480 	call	8ac48 <alt_busy_sleep>
}
   891dc:	e037883a 	mov	sp,fp
   891e0:	dfc00117 	ldw	ra,4(sp)
   891e4:	df000017 	ldw	fp,0(sp)
   891e8:	dec00204 	addi	sp,sp,8
   891ec:	f800283a 	ret

000891f0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   891f0:	defffd04 	addi	sp,sp,-12
   891f4:	dfc00215 	stw	ra,8(sp)
   891f8:	df000115 	stw	fp,4(sp)
   891fc:	df000104 	addi	fp,sp,4
   89200:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU, CPU);
   89204:	008b1700 	call	8b170 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   89208:	00800044 	movi	r2,1
   8920c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   89210:	e037883a 	mov	sp,fp
   89214:	dfc00117 	ldw	ra,4(sp)
   89218:	df000017 	ldw	fp,0(sp)
   8921c:	dec00204 	addi	sp,sp,8
   89220:	f800283a 	ret

00089224 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   89224:	defffd04 	addi	sp,sp,-12
   89228:	dfc00215 	stw	ra,8(sp)
   8922c:	df000115 	stw	fp,4(sp)
   89230:	df000104 	addi	fp,sp,4
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
   89234:	01000274 	movhi	r4,9
   89238:	212d9704 	addi	r4,r4,-18852
   8923c:	008944c0 	call	8944c <alt_dev_reg>
    ALTERA_UP_AVALON_VIDEO_PIXEL_BUFFER_DMA_INIT ( PIXEL_BUFFER_DMA, Pixel_Buffer_DMA);
   89240:	00800274 	movhi	r2,9
   89244:	10ada204 	addi	r2,r2,-18808
   89248:	10800a17 	ldw	r2,40(r2)
   8924c:	10800017 	ldw	r2,0(r2)
   89250:	1007883a 	mov	r3,r2
   89254:	00800274 	movhi	r2,9
   89258:	10ada204 	addi	r2,r2,-18808
   8925c:	10c00b15 	stw	r3,44(r2)
   89260:	00800274 	movhi	r2,9
   89264:	10ada204 	addi	r2,r2,-18808
   89268:	10800a17 	ldw	r2,40(r2)
   8926c:	10800104 	addi	r2,r2,4
   89270:	10800017 	ldw	r2,0(r2)
   89274:	1007883a 	mov	r3,r2
   89278:	00800274 	movhi	r2,9
   8927c:	10ada204 	addi	r2,r2,-18808
   89280:	10c00c15 	stw	r3,48(r2)
   89284:	00800274 	movhi	r2,9
   89288:	10ada204 	addi	r2,r2,-18808
   8928c:	10800a17 	ldw	r2,40(r2)
   89290:	10800204 	addi	r2,r2,8
   89294:	10800017 	ldw	r2,0(r2)
   89298:	10ffffcc 	andi	r3,r2,65535
   8929c:	00800274 	movhi	r2,9
   892a0:	10ada204 	addi	r2,r2,-18808
   892a4:	10c00f15 	stw	r3,60(r2)
   892a8:	00800274 	movhi	r2,9
   892ac:	10ada204 	addi	r2,r2,-18808
   892b0:	10800a17 	ldw	r2,40(r2)
   892b4:	10800204 	addi	r2,r2,8
   892b8:	10800017 	ldw	r2,0(r2)
   892bc:	1005d43a 	srai	r2,r2,16
   892c0:	10ffffcc 	andi	r3,r2,65535
   892c4:	00800274 	movhi	r2,9
   892c8:	10ada204 	addi	r2,r2,-18808
   892cc:	10c01015 	stw	r3,64(r2)
   892d0:	00800274 	movhi	r2,9
   892d4:	10ada204 	addi	r2,r2,-18808
   892d8:	10800a17 	ldw	r2,40(r2)
   892dc:	10800304 	addi	r2,r2,12
   892e0:	10800017 	ldw	r2,0(r2)
   892e4:	1005d07a 	srai	r2,r2,1
   892e8:	10c0004c 	andi	r3,r2,1
   892ec:	00800274 	movhi	r2,9
   892f0:	10ada204 	addi	r2,r2,-18808
   892f4:	10c00d15 	stw	r3,52(r2)
   892f8:	00800274 	movhi	r2,9
   892fc:	10ada204 	addi	r2,r2,-18808
   89300:	10800a17 	ldw	r2,40(r2)
   89304:	10800304 	addi	r2,r2,12
   89308:	10800017 	ldw	r2,0(r2)
   8930c:	1005d13a 	srai	r2,r2,4
   89310:	10c003cc 	andi	r3,r2,15
   89314:	00800274 	movhi	r2,9
   89318:	10ada204 	addi	r2,r2,-18808
   8931c:	10c00e15 	stw	r3,56(r2)
   89320:	00800274 	movhi	r2,9
   89324:	10ada204 	addi	r2,r2,-18808
   89328:	10800a17 	ldw	r2,40(r2)
   8932c:	10800304 	addi	r2,r2,12
   89330:	10800017 	ldw	r2,0(r2)
   89334:	1005d43a 	srai	r2,r2,16
   89338:	1007883a 	mov	r3,r2
   8933c:	00bfffc4 	movi	r2,-1
   89340:	1884703a 	and	r2,r3,r2
   89344:	e0bfff45 	stb	r2,-3(fp)
   89348:	00800274 	movhi	r2,9
   8934c:	10ada204 	addi	r2,r2,-18808
   89350:	10800a17 	ldw	r2,40(r2)
   89354:	10800304 	addi	r2,r2,12
   89358:	10800017 	ldw	r2,0(r2)
   8935c:	1005d63a 	srai	r2,r2,24
   89360:	1007883a 	mov	r3,r2
   89364:	00bfffc4 	movi	r2,-1
   89368:	1884703a 	and	r2,r3,r2
   8936c:	e0bfff05 	stb	r2,-4(fp)
   89370:	00800274 	movhi	r2,9
   89374:	10ada204 	addi	r2,r2,-18808
   89378:	10800e17 	ldw	r2,56(r2)
   8937c:	10800058 	cmpnei	r2,r2,1
   89380:	1000041e 	bne	r2,zero,89394 <alt_sys_init+0x170>
   89384:	00800274 	movhi	r2,9
   89388:	10ada204 	addi	r2,r2,-18808
   8938c:	10001115 	stw	zero,68(r2)
   89390:	00000e06 	br	893cc <alt_sys_init+0x1a8>
   89394:	00800274 	movhi	r2,9
   89398:	10ada204 	addi	r2,r2,-18808
   8939c:	10800e17 	ldw	r2,56(r2)
   893a0:	10800098 	cmpnei	r2,r2,2
   893a4:	1000051e 	bne	r2,zero,893bc <alt_sys_init+0x198>
   893a8:	00c00274 	movhi	r3,9
   893ac:	18eda204 	addi	r3,r3,-18808
   893b0:	00800044 	movi	r2,1
   893b4:	18801115 	stw	r2,68(r3)
   893b8:	00000406 	br	893cc <alt_sys_init+0x1a8>
   893bc:	00c00274 	movhi	r3,9
   893c0:	18eda204 	addi	r3,r3,-18808
   893c4:	00800084 	movi	r2,2
   893c8:	18801115 	stw	r2,68(r3)
   893cc:	e0ffff43 	ldbu	r3,-3(fp)
   893d0:	00800804 	movi	r2,32
   893d4:	10c7c83a 	sub	r3,r2,r3
   893d8:	00bfffc4 	movi	r2,-1
   893dc:	10c6d83a 	srl	r3,r2,r3
   893e0:	00800274 	movhi	r2,9
   893e4:	10ada204 	addi	r2,r2,-18808
   893e8:	10c01215 	stw	r3,72(r2)
   893ec:	e0ffff43 	ldbu	r3,-3(fp)
   893f0:	00800274 	movhi	r2,9
   893f4:	10ada204 	addi	r2,r2,-18808
   893f8:	10801117 	ldw	r2,68(r2)
   893fc:	1887883a 	add	r3,r3,r2
   89400:	00800274 	movhi	r2,9
   89404:	10ada204 	addi	r2,r2,-18808
   89408:	10c01315 	stw	r3,76(r2)
   8940c:	e0ffff03 	ldbu	r3,-4(fp)
   89410:	00800804 	movi	r2,32
   89414:	10c7c83a 	sub	r3,r2,r3
   89418:	00bfffc4 	movi	r2,-1
   8941c:	10c6d83a 	srl	r3,r2,r3
   89420:	00800274 	movhi	r2,9
   89424:	10ada204 	addi	r2,r2,-18808
   89428:	10c01415 	stw	r3,80(r2)
   8942c:	01000274 	movhi	r4,9
   89430:	212da204 	addi	r4,r4,-18808
   89434:	008944c0 	call	8944c <alt_dev_reg>
}
   89438:	e037883a 	mov	sp,fp
   8943c:	dfc00117 	ldw	ra,4(sp)
   89440:	df000017 	ldw	fp,0(sp)
   89444:	dec00204 	addi	sp,sp,8
   89448:	f800283a 	ret

0008944c <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
   8944c:	defffd04 	addi	sp,sp,-12
   89450:	dfc00215 	stw	ra,8(sp)
   89454:	df000115 	stw	fp,4(sp)
   89458:	df000104 	addi	fp,sp,4
   8945c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
   89460:	e13fff17 	ldw	r4,-4(fp)
   89464:	01400274 	movhi	r5,9
   89468:	296e5b04 	addi	r5,r5,-18068
   8946c:	008af380 	call	8af38 <alt_dev_llist_insert>
}
   89470:	e037883a 	mov	sp,fp
   89474:	dfc00117 	ldw	ra,4(sp)
   89478:	df000017 	ldw	fp,0(sp)
   8947c:	dec00204 	addi	sp,sp,8
   89480:	f800283a 	ret

00089484 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   89484:	defffa04 	addi	sp,sp,-24
   89488:	dfc00515 	stw	ra,20(sp)
   8948c:	df000415 	stw	fp,16(sp)
   89490:	df000404 	addi	fp,sp,16
   89494:	e13ffd15 	stw	r4,-12(fp)
   89498:	e17ffe15 	stw	r5,-8(fp)
   8949c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   894a0:	e0bffd17 	ldw	r2,-12(fp)
   894a4:	10800017 	ldw	r2,0(r2)
   894a8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   894ac:	e0bffc17 	ldw	r2,-16(fp)
   894b0:	11000a04 	addi	r4,r2,40
   894b4:	e0bffd17 	ldw	r2,-12(fp)
   894b8:	11c00217 	ldw	r7,8(r2)
   894bc:	e17ffe17 	ldw	r5,-8(fp)
   894c0:	e1bfff17 	ldw	r6,-4(fp)
   894c4:	00895340 	call	89534 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
   894c8:	e037883a 	mov	sp,fp
   894cc:	dfc00117 	ldw	ra,4(sp)
   894d0:	df000017 	ldw	fp,0(sp)
   894d4:	dec00204 	addi	sp,sp,8
   894d8:	f800283a 	ret

000894dc <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   894dc:	defffa04 	addi	sp,sp,-24
   894e0:	dfc00515 	stw	ra,20(sp)
   894e4:	df000415 	stw	fp,16(sp)
   894e8:	df000404 	addi	fp,sp,16
   894ec:	e13ffd15 	stw	r4,-12(fp)
   894f0:	e17ffe15 	stw	r5,-8(fp)
   894f4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   894f8:	e0bffd17 	ldw	r2,-12(fp)
   894fc:	10800017 	ldw	r2,0(r2)
   89500:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   89504:	e0bffc17 	ldw	r2,-16(fp)
   89508:	11000a04 	addi	r4,r2,40
   8950c:	e0bffd17 	ldw	r2,-12(fp)
   89510:	11c00217 	ldw	r7,8(r2)
   89514:	e17ffe17 	ldw	r5,-8(fp)
   89518:	e1bfff17 	ldw	r6,-4(fp)
   8951c:	00896380 	call	89638 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
   89520:	e037883a 	mov	sp,fp
   89524:	dfc00117 	ldw	ra,4(sp)
   89528:	df000017 	ldw	fp,0(sp)
   8952c:	dec00204 	addi	sp,sp,8
   89530:	f800283a 	ret

00089534 <altera_avalon_jtag_uart_read>:
 */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char* buffer, int space, int flags)
{
   89534:	defff604 	addi	sp,sp,-40
   89538:	df000915 	stw	fp,36(sp)
   8953c:	df000904 	addi	fp,sp,36
   89540:	e13ffb15 	stw	r4,-20(fp)
   89544:	e17ffc15 	stw	r5,-16(fp)
   89548:	e1bffd15 	stw	r6,-12(fp)
   8954c:	e1fffe15 	stw	r7,-8(fp)
  unsigned int base = sp->base;
   89550:	e0bffb17 	ldw	r2,-20(fp)
   89554:	10800017 	ldw	r2,0(r2)
   89558:	e0bffa15 	stw	r2,-24(fp)

  char * ptr = buffer;
   8955c:	e0bffc17 	ldw	r2,-16(fp)
   89560:	e0bff915 	stw	r2,-28(fp)
  char * end = buffer + space;
   89564:	e0bffd17 	ldw	r2,-12(fp)
   89568:	1007883a 	mov	r3,r2
   8956c:	e0bffc17 	ldw	r2,-16(fp)
   89570:	10c5883a 	add	r2,r2,r3
   89574:	e0bff815 	stw	r2,-32(fp)

  while (ptr < end)
   89578:	00001606 	br	895d4 <altera_avalon_jtag_uart_read+0xa0>
  {
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
   8957c:	e0bffa17 	ldw	r2,-24(fp)
   89580:	10800037 	ldwio	r2,0(r2)
   89584:	e0bff715 	stw	r2,-36(fp)

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
   89588:	e0bff717 	ldw	r2,-36(fp)
   8958c:	10a0000c 	andi	r2,r2,32768
   89590:	1005003a 	cmpeq	r2,r2,zero
   89594:	1000081e 	bne	r2,zero,895b8 <altera_avalon_jtag_uart_read+0x84>
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
   89598:	e0bff717 	ldw	r2,-36(fp)
   8959c:	1007883a 	mov	r3,r2
   895a0:	e0bff917 	ldw	r2,-28(fp)
   895a4:	10c00005 	stb	r3,0(r2)
   895a8:	e0bff917 	ldw	r2,-28(fp)
   895ac:	10800044 	addi	r2,r2,1
   895b0:	e0bff915 	stw	r2,-28(fp)
   895b4:	00000706 	br	895d4 <altera_avalon_jtag_uart_read+0xa0>
    else if (ptr != buffer)
   895b8:	e0fff917 	ldw	r3,-28(fp)
   895bc:	e0bffc17 	ldw	r2,-16(fp)
   895c0:	1880071e 	bne	r3,r2,895e0 <altera_avalon_jtag_uart_read+0xac>
      break;
    else if(flags & O_NONBLOCK)
   895c4:	e0bffe17 	ldw	r2,-8(fp)
   895c8:	1090000c 	andi	r2,r2,16384
   895cc:	1004c03a 	cmpne	r2,r2,zero
   895d0:	1000031e 	bne	r2,zero,895e0 <altera_avalon_jtag_uart_read+0xac>
  unsigned int base = sp->base;

  char * ptr = buffer;
  char * end = buffer + space;

  while (ptr < end)
   895d4:	e0fff917 	ldw	r3,-28(fp)
   895d8:	e0bff817 	ldw	r2,-32(fp)
   895dc:	18bfe736 	bltu	r3,r2,8957c <altera_avalon_jtag_uart_read+0x48>
    else if(flags & O_NONBLOCK)
      break;   
    
  }

  if (ptr != buffer)
   895e0:	e0fff917 	ldw	r3,-28(fp)
   895e4:	e0bffc17 	ldw	r2,-16(fp)
   895e8:	18800526 	beq	r3,r2,89600 <altera_avalon_jtag_uart_read+0xcc>
    return ptr - buffer;
   895ec:	e0fff917 	ldw	r3,-28(fp)
   895f0:	e0bffc17 	ldw	r2,-16(fp)
   895f4:	1887c83a 	sub	r3,r3,r2
   895f8:	e0ffff15 	stw	r3,-4(fp)
   895fc:	00000906 	br	89624 <altera_avalon_jtag_uart_read+0xf0>
  else if (flags & O_NONBLOCK)
   89600:	e0bffe17 	ldw	r2,-8(fp)
   89604:	1090000c 	andi	r2,r2,16384
   89608:	1005003a 	cmpeq	r2,r2,zero
   8960c:	1000031e 	bne	r2,zero,8961c <altera_avalon_jtag_uart_read+0xe8>
    return -EWOULDBLOCK;
   89610:	00bffd44 	movi	r2,-11
   89614:	e0bfff15 	stw	r2,-4(fp)
   89618:	00000206 	br	89624 <altera_avalon_jtag_uart_read+0xf0>
  else
    return -EIO;
   8961c:	00bffec4 	movi	r2,-5
   89620:	e0bfff15 	stw	r2,-4(fp)
   89624:	e0bfff17 	ldw	r2,-4(fp)
}
   89628:	e037883a 	mov	sp,fp
   8962c:	df000017 	ldw	fp,0(sp)
   89630:	dec00104 	addi	sp,sp,4
   89634:	f800283a 	ret

00089638 <altera_avalon_jtag_uart_write>:
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   89638:	defff904 	addi	sp,sp,-28
   8963c:	df000615 	stw	fp,24(sp)
   89640:	df000604 	addi	fp,sp,24
   89644:	e13ffc15 	stw	r4,-16(fp)
   89648:	e17ffd15 	stw	r5,-12(fp)
   8964c:	e1bffe15 	stw	r6,-8(fp)
   89650:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
   89654:	e0bffc17 	ldw	r2,-16(fp)
   89658:	10800017 	ldw	r2,0(r2)
   8965c:	e0bffb15 	stw	r2,-20(fp)

  const char * end = ptr + count;
   89660:	e0bffe17 	ldw	r2,-8(fp)
   89664:	1007883a 	mov	r3,r2
   89668:	e0bffd17 	ldw	r2,-12(fp)
   8966c:	10c5883a 	add	r2,r2,r3
   89670:	e0bffa15 	stw	r2,-24(fp)

  while (ptr < end)
   89674:	00001106 	br	896bc <altera_avalon_jtag_uart_write+0x84>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   89678:	e0bffb17 	ldw	r2,-20(fp)
   8967c:	10800104 	addi	r2,r2,4
   89680:	10800037 	ldwio	r2,0(r2)
   89684:	10bfffec 	andhi	r2,r2,65535
   89688:	1005003a 	cmpeq	r2,r2,zero
   8968c:	10000b1e 	bne	r2,zero,896bc <altera_avalon_jtag_uart_write+0x84>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
   89690:	e13ffb17 	ldw	r4,-20(fp)
   89694:	e0bffd17 	ldw	r2,-12(fp)
   89698:	10800003 	ldbu	r2,0(r2)
   8969c:	10c03fcc 	andi	r3,r2,255
   896a0:	18c0201c 	xori	r3,r3,128
   896a4:	18ffe004 	addi	r3,r3,-128
   896a8:	e0bffd17 	ldw	r2,-12(fp)
   896ac:	10800044 	addi	r2,r2,1
   896b0:	e0bffd15 	stw	r2,-12(fp)
   896b4:	2005883a 	mov	r2,r4
   896b8:	10c00035 	stwio	r3,0(r2)
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
   896bc:	e0fffd17 	ldw	r3,-12(fp)
   896c0:	e0bffa17 	ldw	r2,-24(fp)
   896c4:	18bfec36 	bltu	r3,r2,89678 <altera_avalon_jtag_uart_write+0x40>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
   896c8:	e0bffe17 	ldw	r2,-8(fp)
}
   896cc:	e037883a 	mov	sp,fp
   896d0:	df000017 	ldw	fp,0(sp)
   896d4:	dec00104 	addi	sp,sp,4
   896d8:	f800283a 	ret

000896dc <alt_up_pixel_buffer_dma_open_dev>:

#include "altera_up_avalon_video_pixel_buffer_dma.h"

#define ABS(x)	((x >= 0) ? (x) : (-(x)))

alt_up_pixel_buffer_dma_dev* alt_up_pixel_buffer_dma_open_dev(const char* name) {
   896dc:	defffc04 	addi	sp,sp,-16
   896e0:	dfc00315 	stw	ra,12(sp)
   896e4:	df000215 	stw	fp,8(sp)
   896e8:	df000204 	addi	fp,sp,8
   896ec:	e13fff15 	stw	r4,-4(fp)
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_pixel_buffer_dma_dev *dev = (alt_up_pixel_buffer_dma_dev*)alt_find_dev(name, &alt_dev_list);
   896f0:	e13fff17 	ldw	r4,-4(fp)
   896f4:	01400274 	movhi	r5,9
   896f8:	296e5b04 	addi	r5,r5,-18068
   896fc:	008b04c0 	call	8b04c <alt_find_dev>
   89700:	e0bffe15 	stw	r2,-8(fp)

  return dev;
   89704:	e0bffe17 	ldw	r2,-8(fp)
}
   89708:	e037883a 	mov	sp,fp
   8970c:	dfc00117 	ldw	ra,4(sp)
   89710:	df000017 	ldw	fp,0(sp)
   89714:	dec00204 	addi	sp,sp,8
   89718:	f800283a 	ret

0008971c <alt_up_pixel_buffer_dma_draw>:

int alt_up_pixel_buffer_dma_draw(alt_up_pixel_buffer_dma_dev *pixel_buffer, unsigned int color, unsigned int x, unsigned int y)
/* This function draws a pixel to the back buffer.
 */
{
   8971c:	defff904 	addi	sp,sp,-28
   89720:	df000615 	stw	fp,24(sp)
   89724:	df000604 	addi	fp,sp,24
   89728:	e13ffb15 	stw	r4,-20(fp)
   8972c:	e17ffc15 	stw	r5,-16(fp)
   89730:	e1bffd15 	stw	r6,-12(fp)
   89734:	e1fffe15 	stw	r7,-8(fp)
	// boundary check
	if (x >= pixel_buffer->x_resolution || y >= pixel_buffer->y_resolution )
   89738:	e0bffb17 	ldw	r2,-20(fp)
   8973c:	10c00f17 	ldw	r3,60(r2)
   89740:	e0bffd17 	ldw	r2,-12(fp)
   89744:	10c0042e 	bgeu	r2,r3,89758 <alt_up_pixel_buffer_dma_draw+0x3c>
   89748:	e0bffb17 	ldw	r2,-20(fp)
   8974c:	10c01017 	ldw	r3,64(r2)
   89750:	e0bffe17 	ldw	r2,-8(fp)
   89754:	10c00336 	bltu	r2,r3,89764 <alt_up_pixel_buffer_dma_draw+0x48>
		return -1;
   89758:	00bfffc4 	movi	r2,-1
   8975c:	e0bfff15 	stw	r2,-4(fp)
   89760:	00005106 	br	898a8 <alt_up_pixel_buffer_dma_draw+0x18c>

	unsigned int addr = 0;
   89764:	e03ffa15 	stw	zero,-24(fp)
	/* Check the mode VGA Pixel Buffer is using. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
   89768:	e0bffb17 	ldw	r2,-20(fp)
   8976c:	10800d17 	ldw	r2,52(r2)
   89770:	1004c03a 	cmpne	r2,r2,zero
   89774:	1000151e 	bne	r2,zero,897cc <alt_up_pixel_buffer_dma_draw+0xb0>
		/* For X-Y addressing mode, the address format is | unused | Y | X |. So shift bits for coordinates X and Y into their respective locations. */
		addr |= ((x & pixel_buffer->x_coord_mask) << pixel_buffer->x_coord_offset);
   89778:	e0bffb17 	ldw	r2,-20(fp)
   8977c:	10c01217 	ldw	r3,72(r2)
   89780:	e0bffd17 	ldw	r2,-12(fp)
   89784:	1886703a 	and	r3,r3,r2
   89788:	e0bffb17 	ldw	r2,-20(fp)
   8978c:	10801117 	ldw	r2,68(r2)
   89790:	1886983a 	sll	r3,r3,r2
   89794:	e0bffa17 	ldw	r2,-24(fp)
   89798:	10c4b03a 	or	r2,r2,r3
   8979c:	e0bffa15 	stw	r2,-24(fp)
		addr |= ((y & pixel_buffer->y_coord_mask) << pixel_buffer->y_coord_offset);
   897a0:	e0bffb17 	ldw	r2,-20(fp)
   897a4:	10c01417 	ldw	r3,80(r2)
   897a8:	e0bffe17 	ldw	r2,-8(fp)
   897ac:	1886703a 	and	r3,r3,r2
   897b0:	e0bffb17 	ldw	r2,-20(fp)
   897b4:	10801317 	ldw	r2,76(r2)
   897b8:	1886983a 	sll	r3,r3,r2
   897bc:	e0bffa17 	ldw	r2,-24(fp)
   897c0:	10c4b03a 	or	r2,r2,r3
   897c4:	e0bffa15 	stw	r2,-24(fp)
   897c8:	00001706 	br	89828 <alt_up_pixel_buffer_dma_draw+0x10c>
	} else {
		/* In a consecutive addressing mode, the pixels are stored in consecutive memory locations. So the address of a pixel at (x,y) can be computed as
		 * (y*x_resolution + x).*/
		addr += ((x & pixel_buffer->x_coord_mask) << pixel_buffer->x_coord_offset);
   897cc:	e0bffb17 	ldw	r2,-20(fp)
   897d0:	10c01217 	ldw	r3,72(r2)
   897d4:	e0bffd17 	ldw	r2,-12(fp)
   897d8:	1886703a 	and	r3,r3,r2
   897dc:	e0bffb17 	ldw	r2,-20(fp)
   897e0:	10801117 	ldw	r2,68(r2)
   897e4:	1886983a 	sll	r3,r3,r2
   897e8:	e0bffa17 	ldw	r2,-24(fp)
   897ec:	10c5883a 	add	r2,r2,r3
   897f0:	e0bffa15 	stw	r2,-24(fp)
		addr += (((y & pixel_buffer->y_coord_mask) * pixel_buffer->x_resolution) << pixel_buffer->x_coord_offset);
   897f4:	e0bffb17 	ldw	r2,-20(fp)
   897f8:	10c01417 	ldw	r3,80(r2)
   897fc:	e0bffe17 	ldw	r2,-8(fp)
   89800:	1886703a 	and	r3,r3,r2
   89804:	e0bffb17 	ldw	r2,-20(fp)
   89808:	10800f17 	ldw	r2,60(r2)
   8980c:	1887383a 	mul	r3,r3,r2
   89810:	e0bffb17 	ldw	r2,-20(fp)
   89814:	10801117 	ldw	r2,68(r2)
   89818:	1886983a 	sll	r3,r3,r2
   8981c:	e0bffa17 	ldw	r2,-24(fp)
   89820:	10c5883a 	add	r2,r2,r3
   89824:	e0bffa15 	stw	r2,-24(fp)
	}
	/* Now, depending on the color depth, write the pixel color to the specified memory location. */
	if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
   89828:	e0bffb17 	ldw	r2,-20(fp)
   8982c:	10800e17 	ldw	r2,56(r2)
   89830:	10800058 	cmpnei	r2,r2,1
   89834:	1000081e 	bne	r2,zero,89858 <alt_up_pixel_buffer_dma_draw+0x13c>
		IOWR_8DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
   89838:	e0bffb17 	ldw	r2,-20(fp)
   8983c:	10800c17 	ldw	r2,48(r2)
   89840:	1007883a 	mov	r3,r2
   89844:	e0bffa17 	ldw	r2,-24(fp)
   89848:	1885883a 	add	r2,r3,r2
   8984c:	e0fffc17 	ldw	r3,-16(fp)
   89850:	10c00025 	stbio	r3,0(r2)
   89854:	00001306 	br	898a4 <alt_up_pixel_buffer_dma_draw+0x188>
	} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
   89858:	e0bffb17 	ldw	r2,-20(fp)
   8985c:	10800e17 	ldw	r2,56(r2)
   89860:	10800098 	cmpnei	r2,r2,2
   89864:	1000081e 	bne	r2,zero,89888 <alt_up_pixel_buffer_dma_draw+0x16c>
		IOWR_16DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
   89868:	e0bffb17 	ldw	r2,-20(fp)
   8986c:	10800c17 	ldw	r2,48(r2)
   89870:	1007883a 	mov	r3,r2
   89874:	e0bffa17 	ldw	r2,-24(fp)
   89878:	1885883a 	add	r2,r3,r2
   8987c:	e0fffc17 	ldw	r3,-16(fp)
   89880:	10c0002d 	sthio	r3,0(r2)
   89884:	00000706 	br	898a4 <alt_up_pixel_buffer_dma_draw+0x188>
	} else {
		IOWR_32DIRECT(pixel_buffer->back_buffer_start_address, addr, color);
   89888:	e0bffb17 	ldw	r2,-20(fp)
   8988c:	10800c17 	ldw	r2,48(r2)
   89890:	1007883a 	mov	r3,r2
   89894:	e0bffa17 	ldw	r2,-24(fp)
   89898:	1885883a 	add	r2,r3,r2
   8989c:	e0fffc17 	ldw	r3,-16(fp)
   898a0:	10c00035 	stwio	r3,0(r2)
	}

	return 0;
   898a4:	e03fff15 	stw	zero,-4(fp)
   898a8:	e0bfff17 	ldw	r2,-4(fp)
}
   898ac:	e037883a 	mov	sp,fp
   898b0:	df000017 	ldw	fp,0(sp)
   898b4:	dec00104 	addi	sp,sp,4
   898b8:	f800283a 	ret

000898bc <alt_up_pixel_buffer_dma_change_back_buffer_address>:

int alt_up_pixel_buffer_dma_change_back_buffer_address(alt_up_pixel_buffer_dma_dev *pixel_buffer, unsigned int new_address)
/* This function changes the memory address for the back buffer. */
{
   898bc:	defffd04 	addi	sp,sp,-12
   898c0:	df000215 	stw	fp,8(sp)
   898c4:	df000204 	addi	fp,sp,8
   898c8:	e13ffe15 	stw	r4,-8(fp)
   898cc:	e17fff15 	stw	r5,-4(fp)
	IOWR_32DIRECT(pixel_buffer->base, 4, new_address);
   898d0:	e0bffe17 	ldw	r2,-8(fp)
   898d4:	10800a17 	ldw	r2,40(r2)
   898d8:	10800104 	addi	r2,r2,4
   898dc:	e0ffff17 	ldw	r3,-4(fp)
   898e0:	10c00035 	stwio	r3,0(r2)
	pixel_buffer->back_buffer_start_address = IORD_32DIRECT(pixel_buffer->base, 4);
   898e4:	e0bffe17 	ldw	r2,-8(fp)
   898e8:	10800a17 	ldw	r2,40(r2)
   898ec:	10800104 	addi	r2,r2,4
   898f0:	10800037 	ldwio	r2,0(r2)
   898f4:	1007883a 	mov	r3,r2
   898f8:	e0bffe17 	ldw	r2,-8(fp)
   898fc:	10c00c15 	stw	r3,48(r2)
	return 0;
   89900:	0005883a 	mov	r2,zero
}
   89904:	e037883a 	mov	sp,fp
   89908:	df000017 	ldw	fp,0(sp)
   8990c:	dec00104 	addi	sp,sp,4
   89910:	f800283a 	ret

00089914 <alt_up_pixel_buffer_dma_swap_buffers>:

int alt_up_pixel_buffer_dma_swap_buffers(alt_up_pixel_buffer_dma_dev *pixel_buffer)
/* This function swaps the front and back buffers. At the next refresh cycle the back buffer will be drawn on the screen
 * and will become the front buffer. */
{
   89914:	defffe04 	addi	sp,sp,-8
   89918:	df000115 	stw	fp,4(sp)
   8991c:	df000104 	addi	fp,sp,4
   89920:	e13fff15 	stw	r4,-4(fp)
	register unsigned int temp = pixel_buffer->back_buffer_start_address;
   89924:	e0bfff17 	ldw	r2,-4(fp)
   89928:	11000c17 	ldw	r4,48(r2)
	IOWR_32DIRECT(pixel_buffer->base, 0, 1);
   8992c:	e0bfff17 	ldw	r2,-4(fp)
   89930:	10800a17 	ldw	r2,40(r2)
   89934:	1007883a 	mov	r3,r2
   89938:	00800044 	movi	r2,1
   8993c:	18800035 	stwio	r2,0(r3)
	pixel_buffer->back_buffer_start_address = pixel_buffer->buffer_start_address;
   89940:	e0bfff17 	ldw	r2,-4(fp)
   89944:	10c00b17 	ldw	r3,44(r2)
   89948:	e0bfff17 	ldw	r2,-4(fp)
   8994c:	10c00c15 	stw	r3,48(r2)
	pixel_buffer->buffer_start_address = temp;
   89950:	e0bfff17 	ldw	r2,-4(fp)
   89954:	11000b15 	stw	r4,44(r2)
	return 0;
   89958:	0005883a 	mov	r2,zero
}
   8995c:	e037883a 	mov	sp,fp
   89960:	df000017 	ldw	fp,0(sp)
   89964:	dec00104 	addi	sp,sp,4
   89968:	f800283a 	ret

0008996c <alt_up_pixel_buffer_dma_check_swap_buffers_status>:
int alt_up_pixel_buffer_dma_check_swap_buffers_status(alt_up_pixel_buffer_dma_dev *pixel_buffer)
/* This function checks if the buffer swap has occured. Since the buffer swap only happens after an entire screen is drawn,
 * it is important to wait for this function to return 0 before proceeding to draw on either buffer. When both front and the back buffers
 * have the same address calling the alt_up_pixel_buffer_dma_swap_buffers(...) function and then waiting for this function to return 0, causes your program to
 * wait for the screen to refresh. */
{
   8996c:	defffe04 	addi	sp,sp,-8
   89970:	df000115 	stw	fp,4(sp)
   89974:	df000104 	addi	fp,sp,4
   89978:	e13fff15 	stw	r4,-4(fp)
	return (IORD_32DIRECT(pixel_buffer->base, 12) & 0x1);
   8997c:	e0bfff17 	ldw	r2,-4(fp)
   89980:	10800a17 	ldw	r2,40(r2)
   89984:	10800304 	addi	r2,r2,12
   89988:	10800037 	ldwio	r2,0(r2)
   8998c:	1080004c 	andi	r2,r2,1
}
   89990:	e037883a 	mov	sp,fp
   89994:	df000017 	ldw	fp,0(sp)
   89998:	dec00104 	addi	sp,sp,4
   8999c:	f800283a 	ret

000899a0 <alt_up_pixel_buffer_dma_clear_screen>:

void alt_up_pixel_buffer_dma_clear_screen(alt_up_pixel_buffer_dma_dev *pixel_buffer, int backbuffer)
/* This function clears the screen by setting each pixel to a black color. */
{
   899a0:	defff604 	addi	sp,sp,-40
   899a4:	df000915 	stw	fp,36(sp)
   899a8:	df000904 	addi	fp,sp,36
   899ac:	e13ff715 	stw	r4,-36(fp)
   899b0:	e17ff815 	stw	r5,-32(fp)
	register unsigned int addr;
	register unsigned int limit_x, limit_y;
	
	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
   899b4:	e0bff817 	ldw	r2,-32(fp)
   899b8:	10800058 	cmpnei	r2,r2,1
   899bc:	1000041e 	bne	r2,zero,899d0 <alt_up_pixel_buffer_dma_clear_screen+0x30>
		addr = pixel_buffer->back_buffer_start_address;
   899c0:	e0bff717 	ldw	r2,-36(fp)
   899c4:	10800c17 	ldw	r2,48(r2)
   899c8:	e0bfff15 	stw	r2,-4(fp)
   899cc:	00000306 	br	899dc <alt_up_pixel_buffer_dma_clear_screen+0x3c>
	else
		addr = pixel_buffer->buffer_start_address;
   899d0:	e0bff717 	ldw	r2,-36(fp)
   899d4:	10800b17 	ldw	r2,44(r2)
   899d8:	e0bfff15 	stw	r2,-4(fp)
	limit_x = pixel_buffer->x_resolution;
   899dc:	e0bff717 	ldw	r2,-36(fp)
   899e0:	10800f17 	ldw	r2,60(r2)
   899e4:	e0bffe15 	stw	r2,-8(fp)
	/* In 16 and 32-bit color modes we use twice or four times more memory for the display buffer.*/
	if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
   899e8:	e0bff717 	ldw	r2,-36(fp)
   899ec:	10800e17 	ldw	r2,56(r2)
   899f0:	10800098 	cmpnei	r2,r2,2
   899f4:	1000051e 	bne	r2,zero,89a0c <alt_up_pixel_buffer_dma_clear_screen+0x6c>
		limit_x = limit_x << 1;
   899f8:	e0fffe17 	ldw	r3,-8(fp)
   899fc:	e0fffe17 	ldw	r3,-8(fp)
   89a00:	18c5883a 	add	r2,r3,r3
   89a04:	e0bffe15 	stw	r2,-8(fp)
   89a08:	00000506 	br	89a20 <alt_up_pixel_buffer_dma_clear_screen+0x80>
	} else {
		limit_x = limit_x << 2;
   89a0c:	e13ffe17 	ldw	r4,-8(fp)
   89a10:	e13ffe17 	ldw	r4,-8(fp)
   89a14:	2105883a 	add	r2,r4,r4
   89a18:	1085883a 	add	r2,r2,r2
   89a1c:	e0bffe15 	stw	r2,-8(fp)
	}	
	limit_y = pixel_buffer->y_resolution;
   89a20:	e0bff717 	ldw	r2,-36(fp)
   89a24:	10801017 	ldw	r2,64(r2)
   89a28:	e0bffd15 	stw	r2,-12(fp)

	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
   89a2c:	e0bff717 	ldw	r2,-36(fp)
   89a30:	10800d17 	ldw	r2,52(r2)
   89a34:	1004c03a 	cmpne	r2,r2,zero
   89a38:	10001e1e 	bne	r2,zero,89ab4 <alt_up_pixel_buffer_dma_clear_screen+0x114>
		/* Clear the screen when the VGA is set up in an XY addressing mode. */
		register unsigned int x,y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
   89a3c:	e0bff717 	ldw	r2,-36(fp)
   89a40:	10801317 	ldw	r2,76(r2)
   89a44:	e0bffa15 	stw	r2,-24(fp)

		for (y = 0; y < limit_y; y++)
   89a48:	e03ffb15 	stw	zero,-20(fp)
   89a4c:	00001506 	br	89aa4 <alt_up_pixel_buffer_dma_clear_screen+0x104>
		{
			for (x = 0; x < limit_x; x = x + 4)
   89a50:	e03ffc15 	stw	zero,-16(fp)
   89a54:	00000706 	br	89a74 <alt_up_pixel_buffer_dma_clear_screen+0xd4>
			{
				IOWR_32DIRECT(addr, x, 0);
   89a58:	e0ffff17 	ldw	r3,-4(fp)
   89a5c:	e0bffc17 	ldw	r2,-16(fp)
   89a60:	1885883a 	add	r2,r3,r2
   89a64:	10000035 	stwio	zero,0(r2)
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;

		for (y = 0; y < limit_y; y++)
		{
			for (x = 0; x < limit_x; x = x + 4)
   89a68:	e0bffc17 	ldw	r2,-16(fp)
   89a6c:	10800104 	addi	r2,r2,4
   89a70:	e0bffc15 	stw	r2,-16(fp)
   89a74:	e0fffc17 	ldw	r3,-16(fp)
   89a78:	e13ffe17 	ldw	r4,-8(fp)
   89a7c:	193ff636 	bltu	r3,r4,89a58 <alt_up_pixel_buffer_dma_clear_screen+0xb8>
			{
				IOWR_32DIRECT(addr, x, 0);
			}
			addr = addr + (1 << offset_y);
   89a80:	e0fffa17 	ldw	r3,-24(fp)
   89a84:	00800044 	movi	r2,1
   89a88:	10c4983a 	sll	r2,r2,r3
   89a8c:	e0ffff17 	ldw	r3,-4(fp)
   89a90:	1887883a 	add	r3,r3,r2
   89a94:	e0ffff15 	stw	r3,-4(fp)
		/* Clear the screen when the VGA is set up in an XY addressing mode. */
		register unsigned int x,y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;

		for (y = 0; y < limit_y; y++)
   89a98:	e13ffb17 	ldw	r4,-20(fp)
   89a9c:	21000044 	addi	r4,r4,1
   89aa0:	e13ffb15 	stw	r4,-20(fp)
   89aa4:	e0bffb17 	ldw	r2,-20(fp)
   89aa8:	e0fffd17 	ldw	r3,-12(fp)
   89aac:	10ffe836 	bltu	r2,r3,89a50 <alt_up_pixel_buffer_dma_clear_screen+0xb0>
   89ab0:	00001006 	br	89af4 <alt_up_pixel_buffer_dma_clear_screen+0x154>
			addr = addr + (1 << offset_y);
		}
	} else {
		/* Clear the screen when the VGA is set up in a linear addressing mode. */
		register int x;
		limit_y = limit_x*limit_y;	
   89ab4:	e13ffd17 	ldw	r4,-12(fp)
   89ab8:	e0bffe17 	ldw	r2,-8(fp)
   89abc:	2089383a 	mul	r4,r4,r2
   89ac0:	e13ffd15 	stw	r4,-12(fp)

		for (x = 0; x < limit_y; x = x + 4)
   89ac4:	e03ff915 	stw	zero,-28(fp)
   89ac8:	00000706 	br	89ae8 <alt_up_pixel_buffer_dma_clear_screen+0x148>
		{
			IOWR_32DIRECT(addr, x, 0);
   89acc:	e0ffff17 	ldw	r3,-4(fp)
   89ad0:	e0bff917 	ldw	r2,-28(fp)
   89ad4:	1885883a 	add	r2,r3,r2
   89ad8:	10000035 	stwio	zero,0(r2)
	} else {
		/* Clear the screen when the VGA is set up in a linear addressing mode. */
		register int x;
		limit_y = limit_x*limit_y;	

		for (x = 0; x < limit_y; x = x + 4)
   89adc:	e0fff917 	ldw	r3,-28(fp)
   89ae0:	18c00104 	addi	r3,r3,4
   89ae4:	e0fff915 	stw	r3,-28(fp)
   89ae8:	e0bff917 	ldw	r2,-28(fp)
   89aec:	e13ffd17 	ldw	r4,-12(fp)
   89af0:	113ff636 	bltu	r2,r4,89acc <alt_up_pixel_buffer_dma_clear_screen+0x12c>
		{
			IOWR_32DIRECT(addr, x, 0);
		}
	}
}
   89af4:	e037883a 	mov	sp,fp
   89af8:	df000017 	ldw	fp,0(sp)
   89afc:	dec00104 	addi	sp,sp,4
   89b00:	f800283a 	ret

00089b04 <alt_up_pixel_buffer_dma_draw_box>:

void alt_up_pixel_buffer_dma_draw_box(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
/* This function draws a filled box. */
{
   89b04:	deffed04 	addi	sp,sp,-76
   89b08:	df001215 	stw	fp,72(sp)
   89b0c:	df001204 	addi	fp,sp,72
   89b10:	e13fee15 	stw	r4,-72(fp)
   89b14:	e17fef15 	stw	r5,-68(fp)
   89b18:	e1bff015 	stw	r6,-64(fp)
   89b1c:	e1fff115 	stw	r7,-60(fp)
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
   89b20:	e0bfee17 	ldw	r2,-72(fp)
   89b24:	10800f17 	ldw	r2,60(r2)
   89b28:	e0bffe15 	stw	r2,-8(fp)
	register unsigned int limit_y = pixel_buffer->y_resolution;
   89b2c:	e0bfee17 	ldw	r2,-72(fp)
   89b30:	10801017 	ldw	r2,64(r2)
   89b34:	e0bffd15 	stw	r2,-12(fp)
	register unsigned int temp;
	register unsigned int l_x = x0;
   89b38:	e0bfef17 	ldw	r2,-68(fp)
   89b3c:	e0bffb15 	stw	r2,-20(fp)
	register unsigned int r_x = x1;
   89b40:	e0fff117 	ldw	r3,-60(fp)
   89b44:	e0fffa15 	stw	r3,-24(fp)
	register unsigned int t_y = y0;
   89b48:	e13ff017 	ldw	r4,-64(fp)
   89b4c:	e13ff915 	stw	r4,-28(fp)
	register unsigned int b_y = y1;
   89b50:	e0800117 	ldw	r2,4(fp)
   89b54:	e0bff815 	stw	r2,-32(fp)
	register unsigned int local_color = color;
   89b58:	e0c00217 	ldw	r3,8(fp)
   89b5c:	e0fff715 	stw	r3,-36(fp)
	
	/* Check coordinates */
	if (l_x > r_x)
   89b60:	e13ffa17 	ldw	r4,-24(fp)
   89b64:	e0bffb17 	ldw	r2,-20(fp)
   89b68:	2080062e 	bgeu	r4,r2,89b84 <alt_up_pixel_buffer_dma_draw_box+0x80>
	{
		temp = l_x;
   89b6c:	e0fffb17 	ldw	r3,-20(fp)
   89b70:	e0fffc15 	stw	r3,-16(fp)
		l_x = r_x;
   89b74:	e13ffa17 	ldw	r4,-24(fp)
   89b78:	e13ffb15 	stw	r4,-20(fp)
		r_x = temp;
   89b7c:	e0bffc17 	ldw	r2,-16(fp)
   89b80:	e0bffa15 	stw	r2,-24(fp)
	}
	if (t_y > b_y)
   89b84:	e0fff817 	ldw	r3,-32(fp)
   89b88:	e13ff917 	ldw	r4,-28(fp)
   89b8c:	1900062e 	bgeu	r3,r4,89ba8 <alt_up_pixel_buffer_dma_draw_box+0xa4>
	{
		temp = t_y;
   89b90:	e0bff917 	ldw	r2,-28(fp)
   89b94:	e0bffc15 	stw	r2,-16(fp)
		t_y = b_y;
   89b98:	e0fff817 	ldw	r3,-32(fp)
   89b9c:	e0fff915 	stw	r3,-28(fp)
		b_y = temp;
   89ba0:	e13ffc17 	ldw	r4,-16(fp)
   89ba4:	e13ff815 	stw	r4,-32(fp)
	}
	if ((l_x >= limit_x) || (t_y >= limit_y) || (r_x < 0) || (b_y < 0))
   89ba8:	e0bffb17 	ldw	r2,-20(fp)
   89bac:	e0fffe17 	ldw	r3,-8(fp)
   89bb0:	10c10d2e 	bgeu	r2,r3,89fe8 <alt_up_pixel_buffer_dma_draw_box+0x4e4>
   89bb4:	e13ff917 	ldw	r4,-28(fp)
   89bb8:	e0bffd17 	ldw	r2,-12(fp)
   89bbc:	20800136 	bltu	r4,r2,89bc4 <alt_up_pixel_buffer_dma_draw_box+0xc0>
	{
		/* Drawing outside of the window, so don't bother. */
		return;
   89bc0:	00010906 	br	89fe8 <alt_up_pixel_buffer_dma_draw_box+0x4e4>
	/* Clip the box and draw only within the confines of the screen. */
	if (l_x < 0)
	{
		l_x = 0;
	}
	if (r_x >= limit_x)
   89bc4:	e0fffa17 	ldw	r3,-24(fp)
   89bc8:	e13ffe17 	ldw	r4,-8(fp)
   89bcc:	19000336 	bltu	r3,r4,89bdc <alt_up_pixel_buffer_dma_draw_box+0xd8>
	{
		r_x = limit_x - 1;
   89bd0:	e0bffe17 	ldw	r2,-8(fp)
   89bd4:	10bfffc4 	addi	r2,r2,-1
   89bd8:	e0bffa15 	stw	r2,-24(fp)
	}
	if (t_y < 0)
	{
		t_y = 0;
	}
	if (b_y >= limit_y)
   89bdc:	e0fff817 	ldw	r3,-32(fp)
   89be0:	e13ffd17 	ldw	r4,-12(fp)
   89be4:	19000336 	bltu	r3,r4,89bf4 <alt_up_pixel_buffer_dma_draw_box+0xf0>
	{
		b_y = limit_y - 1;
   89be8:	e0bffd17 	ldw	r2,-12(fp)
   89bec:	10bfffc4 	addi	r2,r2,-1
   89bf0:	e0bff815 	stw	r2,-32(fp)
	}

	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
   89bf4:	e0800317 	ldw	r2,12(fp)
   89bf8:	10800058 	cmpnei	r2,r2,1
   89bfc:	1000041e 	bne	r2,zero,89c10 <alt_up_pixel_buffer_dma_draw_box+0x10c>
		addr = pixel_buffer->back_buffer_start_address;
   89c00:	e0bfee17 	ldw	r2,-72(fp)
   89c04:	10800c17 	ldw	r2,48(r2)
   89c08:	e0bfff15 	stw	r2,-4(fp)
   89c0c:	00000306 	br	89c1c <alt_up_pixel_buffer_dma_draw_box+0x118>
	else
		addr = pixel_buffer->buffer_start_address;
   89c10:	e0bfee17 	ldw	r2,-72(fp)
   89c14:	10800b17 	ldw	r2,44(r2)
   89c18:	e0bfff15 	stw	r2,-4(fp)

	/* Draw the box using one of the addressing modes. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
   89c1c:	e0bfee17 	ldw	r2,-72(fp)
   89c20:	10800d17 	ldw	r2,52(r2)
   89c24:	1004c03a 	cmpne	r2,r2,zero
   89c28:	1000721e 	bne	r2,zero,89df4 <alt_up_pixel_buffer_dma_draw_box+0x2f0>
		/* Draw a box of a given color on the screen using the XY addressing mode. */
		register unsigned int x,y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
   89c2c:	e0bfee17 	ldw	r2,-72(fp)
   89c30:	10801317 	ldw	r2,76(r2)
   89c34:	e0bff415 	stw	r2,-48(fp)
		addr = addr + (t_y << offset_y);
   89c38:	e0bff417 	ldw	r2,-48(fp)
   89c3c:	e0fff917 	ldw	r3,-28(fp)
   89c40:	1884983a 	sll	r2,r3,r2
   89c44:	e13fff17 	ldw	r4,-4(fp)
   89c48:	2089883a 	add	r4,r4,r2
   89c4c:	e13fff15 	stw	r4,-4(fp)
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
   89c50:	e0bfee17 	ldw	r2,-72(fp)
   89c54:	10800e17 	ldw	r2,56(r2)
   89c58:	10800058 	cmpnei	r2,r2,1
   89c5c:	10001e1e 	bne	r2,zero,89cd8 <alt_up_pixel_buffer_dma_draw_box+0x1d4>
			for (y = t_y; y <= b_y; y++)
   89c60:	e0bff917 	ldw	r2,-28(fp)
   89c64:	e0bff515 	stw	r2,-44(fp)
   89c68:	00001706 	br	89cc8 <alt_up_pixel_buffer_dma_draw_box+0x1c4>
			{
				for (x = l_x; x <= r_x; x++)
   89c6c:	e0fffb17 	ldw	r3,-20(fp)
   89c70:	e0fff615 	stw	r3,-40(fp)
   89c74:	00000806 	br	89c98 <alt_up_pixel_buffer_dma_draw_box+0x194>
				{
					IOWR_8DIRECT(addr, x, local_color);
   89c78:	e0ffff17 	ldw	r3,-4(fp)
   89c7c:	e0bff617 	ldw	r2,-40(fp)
   89c80:	1885883a 	add	r2,r3,r2
   89c84:	e0fff717 	ldw	r3,-36(fp)
   89c88:	10c00025 	stbio	r3,0(r2)
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
   89c8c:	e13ff617 	ldw	r4,-40(fp)
   89c90:	21000044 	addi	r4,r4,1
   89c94:	e13ff615 	stw	r4,-40(fp)
   89c98:	e0bffa17 	ldw	r2,-24(fp)
   89c9c:	e0fff617 	ldw	r3,-40(fp)
   89ca0:	10fff52e 	bgeu	r2,r3,89c78 <alt_up_pixel_buffer_dma_draw_box+0x174>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + (1 << offset_y);
   89ca4:	e0fff417 	ldw	r3,-48(fp)
   89ca8:	00800044 	movi	r2,1
   89cac:	10c4983a 	sll	r2,r2,r3
   89cb0:	e13fff17 	ldw	r4,-4(fp)
   89cb4:	2089883a 	add	r4,r4,r2
   89cb8:	e13fff15 	stw	r4,-4(fp)
		addr = addr + (t_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
   89cbc:	e0bff517 	ldw	r2,-44(fp)
   89cc0:	10800044 	addi	r2,r2,1
   89cc4:	e0bff515 	stw	r2,-44(fp)
   89cc8:	e0fff817 	ldw	r3,-32(fp)
   89ccc:	e13ff517 	ldw	r4,-44(fp)
   89cd0:	193fe62e 	bgeu	r3,r4,89c6c <alt_up_pixel_buffer_dma_draw_box+0x168>
   89cd4:	0000c406 	br	89fe8 <alt_up_pixel_buffer_dma_draw_box+0x4e4>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
   89cd8:	e0bfee17 	ldw	r2,-72(fp)
   89cdc:	10800e17 	ldw	r2,56(r2)
   89ce0:	10800098 	cmpnei	r2,r2,2
   89ce4:	1000211e 	bne	r2,zero,89d6c <alt_up_pixel_buffer_dma_draw_box+0x268>
			for (y = t_y; y <= b_y; y++)
   89ce8:	e0bff917 	ldw	r2,-28(fp)
   89cec:	e0bff515 	stw	r2,-44(fp)
   89cf0:	00001a06 	br	89d5c <alt_up_pixel_buffer_dma_draw_box+0x258>
			{
				for (x = l_x; x <= r_x; x++)
   89cf4:	e0fffb17 	ldw	r3,-20(fp)
   89cf8:	e0fff615 	stw	r3,-40(fp)
   89cfc:	00000b06 	br	89d2c <alt_up_pixel_buffer_dma_draw_box+0x228>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
   89d00:	e13ff617 	ldw	r4,-40(fp)
   89d04:	e13ff617 	ldw	r4,-40(fp)
   89d08:	2105883a 	add	r2,r4,r4
   89d0c:	1007883a 	mov	r3,r2
   89d10:	e0bfff17 	ldw	r2,-4(fp)
   89d14:	1885883a 	add	r2,r3,r2
   89d18:	e0fff717 	ldw	r3,-36(fp)
   89d1c:	10c0002d 	sthio	r3,0(r2)
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
   89d20:	e0bff617 	ldw	r2,-40(fp)
   89d24:	10800044 	addi	r2,r2,1
   89d28:	e0bff615 	stw	r2,-40(fp)
   89d2c:	e0fffa17 	ldw	r3,-24(fp)
   89d30:	e13ff617 	ldw	r4,-40(fp)
   89d34:	193ff22e 	bgeu	r3,r4,89d00 <alt_up_pixel_buffer_dma_draw_box+0x1fc>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
				}
				addr = addr + (1 << offset_y);
   89d38:	e0fff417 	ldw	r3,-48(fp)
   89d3c:	00800044 	movi	r2,1
   89d40:	10c4983a 	sll	r2,r2,r3
   89d44:	e0ffff17 	ldw	r3,-4(fp)
   89d48:	1887883a 	add	r3,r3,r2
   89d4c:	e0ffff15 	stw	r3,-4(fp)
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
   89d50:	e13ff517 	ldw	r4,-44(fp)
   89d54:	21000044 	addi	r4,r4,1
   89d58:	e13ff515 	stw	r4,-44(fp)
   89d5c:	e0bff817 	ldw	r2,-32(fp)
   89d60:	e0fff517 	ldw	r3,-44(fp)
   89d64:	10ffe32e 	bgeu	r2,r3,89cf4 <alt_up_pixel_buffer_dma_draw_box+0x1f0>
   89d68:	00009f06 	br	89fe8 <alt_up_pixel_buffer_dma_draw_box+0x4e4>
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
   89d6c:	e13ff917 	ldw	r4,-28(fp)
   89d70:	e13ff515 	stw	r4,-44(fp)
   89d74:	00001b06 	br	89de4 <alt_up_pixel_buffer_dma_draw_box+0x2e0>
			{
				for (x = l_x; x <= r_x; x++)
   89d78:	e0bffb17 	ldw	r2,-20(fp)
   89d7c:	e0bff615 	stw	r2,-40(fp)
   89d80:	00000c06 	br	89db4 <alt_up_pixel_buffer_dma_draw_box+0x2b0>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
   89d84:	e0fff617 	ldw	r3,-40(fp)
   89d88:	e0fff617 	ldw	r3,-40(fp)
   89d8c:	18c5883a 	add	r2,r3,r3
   89d90:	1085883a 	add	r2,r2,r2
   89d94:	1007883a 	mov	r3,r2
   89d98:	e0bfff17 	ldw	r2,-4(fp)
   89d9c:	1885883a 	add	r2,r3,r2
   89da0:	e0fff717 	ldw	r3,-36(fp)
   89da4:	10c00035 	stwio	r3,0(r2)
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
   89da8:	e13ff617 	ldw	r4,-40(fp)
   89dac:	21000044 	addi	r4,r4,1
   89db0:	e13ff615 	stw	r4,-40(fp)
   89db4:	e0bffa17 	ldw	r2,-24(fp)
   89db8:	e0fff617 	ldw	r3,-40(fp)
   89dbc:	10fff12e 	bgeu	r2,r3,89d84 <alt_up_pixel_buffer_dma_draw_box+0x280>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
				}
				addr = addr + (1 << offset_y);
   89dc0:	e0fff417 	ldw	r3,-48(fp)
   89dc4:	00800044 	movi	r2,1
   89dc8:	10c4983a 	sll	r2,r2,r3
   89dcc:	e13fff17 	ldw	r4,-4(fp)
   89dd0:	2089883a 	add	r4,r4,r2
   89dd4:	e13fff15 	stw	r4,-4(fp)
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
   89dd8:	e0bff517 	ldw	r2,-44(fp)
   89ddc:	10800044 	addi	r2,r2,1
   89de0:	e0bff515 	stw	r2,-44(fp)
   89de4:	e0fff817 	ldw	r3,-32(fp)
   89de8:	e13ff517 	ldw	r4,-44(fp)
   89dec:	193fe22e 	bgeu	r3,r4,89d78 <alt_up_pixel_buffer_dma_draw_box+0x274>
   89df0:	00007d06 	br	89fe8 <alt_up_pixel_buffer_dma_draw_box+0x4e4>
	} else {
		/* Draw a box of a given color on the screen using the linear addressing mode. */
		register unsigned int x,y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
   89df4:	e0bfee17 	ldw	r2,-72(fp)
   89df8:	10800e17 	ldw	r2,56(r2)
   89dfc:	10800058 	cmpnei	r2,r2,1
   89e00:	1000221e 	bne	r2,zero,89e8c <alt_up_pixel_buffer_dma_draw_box+0x388>
			addr = addr + t_y * limit_x;
   89e04:	e0fff917 	ldw	r3,-28(fp)
   89e08:	e13ffe17 	ldw	r4,-8(fp)
   89e0c:	1905383a 	mul	r2,r3,r4
   89e10:	e0ffff17 	ldw	r3,-4(fp)
   89e14:	1887883a 	add	r3,r3,r2
   89e18:	e0ffff15 	stw	r3,-4(fp)
			for (y = t_y; y <= b_y; y++)
   89e1c:	e13ff917 	ldw	r4,-28(fp)
   89e20:	e13ff215 	stw	r4,-56(fp)
   89e24:	00001506 	br	89e7c <alt_up_pixel_buffer_dma_draw_box+0x378>
			{
				for (x = l_x; x <= r_x; x++)
   89e28:	e0bffb17 	ldw	r2,-20(fp)
   89e2c:	e0bff315 	stw	r2,-52(fp)
   89e30:	00000806 	br	89e54 <alt_up_pixel_buffer_dma_draw_box+0x350>
				{
					IOWR_8DIRECT(addr, x, local_color);
   89e34:	e0ffff17 	ldw	r3,-4(fp)
   89e38:	e0bff317 	ldw	r2,-52(fp)
   89e3c:	1885883a 	add	r2,r3,r2
   89e40:	e0fff717 	ldw	r3,-36(fp)
   89e44:	10c00025 	stbio	r3,0(r2)
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
   89e48:	e0fff317 	ldw	r3,-52(fp)
   89e4c:	18c00044 	addi	r3,r3,1
   89e50:	e0fff315 	stw	r3,-52(fp)
   89e54:	e13ffa17 	ldw	r4,-24(fp)
   89e58:	e0bff317 	ldw	r2,-52(fp)
   89e5c:	20bff52e 	bgeu	r4,r2,89e34 <alt_up_pixel_buffer_dma_draw_box+0x330>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + limit_x;
   89e60:	e0ffff17 	ldw	r3,-4(fp)
   89e64:	e13ffe17 	ldw	r4,-8(fp)
   89e68:	1907883a 	add	r3,r3,r4
   89e6c:	e0ffff15 	stw	r3,-4(fp)
		register unsigned int x,y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
   89e70:	e0bff217 	ldw	r2,-56(fp)
   89e74:	10800044 	addi	r2,r2,1
   89e78:	e0bff215 	stw	r2,-56(fp)
   89e7c:	e0fff817 	ldw	r3,-32(fp)
   89e80:	e13ff217 	ldw	r4,-56(fp)
   89e84:	193fe82e 	bgeu	r3,r4,89e28 <alt_up_pixel_buffer_dma_draw_box+0x324>
   89e88:	00005706 	br	89fe8 <alt_up_pixel_buffer_dma_draw_box+0x4e4>
				{
					IOWR_8DIRECT(addr, x, local_color);
				}
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
   89e8c:	e0bfee17 	ldw	r2,-72(fp)
   89e90:	10800e17 	ldw	r2,56(r2)
   89e94:	10800098 	cmpnei	r2,r2,2
   89e98:	1000291e 	bne	r2,zero,89f40 <alt_up_pixel_buffer_dma_draw_box+0x43c>
			limit_x = limit_x << 1;
   89e9c:	e0fffe17 	ldw	r3,-8(fp)
   89ea0:	e0fffe17 	ldw	r3,-8(fp)
   89ea4:	18c5883a 	add	r2,r3,r3
   89ea8:	e0bffe15 	stw	r2,-8(fp)
			addr = addr + t_y * limit_x;
   89eac:	e13ff917 	ldw	r4,-28(fp)
   89eb0:	e0fffe17 	ldw	r3,-8(fp)
   89eb4:	20c5383a 	mul	r2,r4,r3
   89eb8:	e13fff17 	ldw	r4,-4(fp)
   89ebc:	2089883a 	add	r4,r4,r2
   89ec0:	e13fff15 	stw	r4,-4(fp)
			for (y = t_y; y <= b_y; y++)
   89ec4:	e0bff917 	ldw	r2,-28(fp)
   89ec8:	e0bff215 	stw	r2,-56(fp)
   89ecc:	00001806 	br	89f30 <alt_up_pixel_buffer_dma_draw_box+0x42c>
			{
				for (x = l_x; x <= r_x; x++)
   89ed0:	e0fffb17 	ldw	r3,-20(fp)
   89ed4:	e0fff315 	stw	r3,-52(fp)
   89ed8:	00000b06 	br	89f08 <alt_up_pixel_buffer_dma_draw_box+0x404>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
   89edc:	e13ff317 	ldw	r4,-52(fp)
   89ee0:	e13ff317 	ldw	r4,-52(fp)
   89ee4:	2105883a 	add	r2,r4,r4
   89ee8:	1007883a 	mov	r3,r2
   89eec:	e0bfff17 	ldw	r2,-4(fp)
   89ef0:	1885883a 	add	r2,r3,r2
   89ef4:	e0fff717 	ldw	r3,-36(fp)
   89ef8:	10c0002d 	sthio	r3,0(r2)
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
   89efc:	e0bff317 	ldw	r2,-52(fp)
   89f00:	10800044 	addi	r2,r2,1
   89f04:	e0bff315 	stw	r2,-52(fp)
   89f08:	e0fffa17 	ldw	r3,-24(fp)
   89f0c:	e13ff317 	ldw	r4,-52(fp)
   89f10:	193ff22e 	bgeu	r3,r4,89edc <alt_up_pixel_buffer_dma_draw_box+0x3d8>
				{
					IOWR_16DIRECT(addr, x << 1, local_color);
				}
				addr = addr + limit_x;
   89f14:	e0bfff17 	ldw	r2,-4(fp)
   89f18:	e0fffe17 	ldw	r3,-8(fp)
   89f1c:	10c5883a 	add	r2,r2,r3
   89f20:	e0bfff15 	stw	r2,-4(fp)
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
   89f24:	e13ff217 	ldw	r4,-56(fp)
   89f28:	21000044 	addi	r4,r4,1
   89f2c:	e13ff215 	stw	r4,-56(fp)
   89f30:	e0bff817 	ldw	r2,-32(fp)
   89f34:	e0fff217 	ldw	r3,-56(fp)
   89f38:	10ffe52e 	bgeu	r2,r3,89ed0 <alt_up_pixel_buffer_dma_draw_box+0x3cc>
   89f3c:	00002a06 	br	89fe8 <alt_up_pixel_buffer_dma_draw_box+0x4e4>
				addr = addr + limit_x;
			}
		}
		else
		{
			limit_x = limit_x << 2;
   89f40:	e13ffe17 	ldw	r4,-8(fp)
   89f44:	e13ffe17 	ldw	r4,-8(fp)
   89f48:	2105883a 	add	r2,r4,r4
   89f4c:	1085883a 	add	r2,r2,r2
   89f50:	e0bffe15 	stw	r2,-8(fp)
			addr = addr + t_y * limit_x;
   89f54:	e0fff917 	ldw	r3,-28(fp)
   89f58:	e13ffe17 	ldw	r4,-8(fp)
   89f5c:	1905383a 	mul	r2,r3,r4
   89f60:	e0ffff17 	ldw	r3,-4(fp)
   89f64:	1887883a 	add	r3,r3,r2
   89f68:	e0ffff15 	stw	r3,-4(fp)
			for (y = t_y; y <= b_y; y++)
   89f6c:	e13ff917 	ldw	r4,-28(fp)
   89f70:	e13ff215 	stw	r4,-56(fp)
   89f74:	00001906 	br	89fdc <alt_up_pixel_buffer_dma_draw_box+0x4d8>
			{
				for (x = l_x; x <= r_x; x++)
   89f78:	e0bffb17 	ldw	r2,-20(fp)
   89f7c:	e0bff315 	stw	r2,-52(fp)
   89f80:	00000c06 	br	89fb4 <alt_up_pixel_buffer_dma_draw_box+0x4b0>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
   89f84:	e0fff317 	ldw	r3,-52(fp)
   89f88:	e0fff317 	ldw	r3,-52(fp)
   89f8c:	18c5883a 	add	r2,r3,r3
   89f90:	1085883a 	add	r2,r2,r2
   89f94:	1007883a 	mov	r3,r2
   89f98:	e0bfff17 	ldw	r2,-4(fp)
   89f9c:	1885883a 	add	r2,r3,r2
   89fa0:	e0fff717 	ldw	r3,-36(fp)
   89fa4:	10c00035 	stwio	r3,0(r2)
		{
			limit_x = limit_x << 2;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
			{
				for (x = l_x; x <= r_x; x++)
   89fa8:	e13ff317 	ldw	r4,-52(fp)
   89fac:	21000044 	addi	r4,r4,1
   89fb0:	e13ff315 	stw	r4,-52(fp)
   89fb4:	e0bffa17 	ldw	r2,-24(fp)
   89fb8:	e0fff317 	ldw	r3,-52(fp)
   89fbc:	10fff12e 	bgeu	r2,r3,89f84 <alt_up_pixel_buffer_dma_draw_box+0x480>
				{
					IOWR_32DIRECT(addr, x << 2, local_color);
				}
				addr = addr + limit_x;
   89fc0:	e13fff17 	ldw	r4,-4(fp)
   89fc4:	e0bffe17 	ldw	r2,-8(fp)
   89fc8:	2089883a 	add	r4,r4,r2
   89fcc:	e13fff15 	stw	r4,-4(fp)
		}
		else
		{
			limit_x = limit_x << 2;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
   89fd0:	e0fff217 	ldw	r3,-56(fp)
   89fd4:	18c00044 	addi	r3,r3,1
   89fd8:	e0fff215 	stw	r3,-56(fp)
   89fdc:	e13ff817 	ldw	r4,-32(fp)
   89fe0:	e0bff217 	ldw	r2,-56(fp)
   89fe4:	20bfe42e 	bgeu	r4,r2,89f78 <alt_up_pixel_buffer_dma_draw_box+0x474>
				}
				addr = addr + limit_x;
			}
		}
	}
}
   89fe8:	e037883a 	mov	sp,fp
   89fec:	df000017 	ldw	fp,0(sp)
   89ff0:	dec00104 	addi	sp,sp,4
   89ff4:	f800283a 	ret

00089ff8 <alt_up_pixel_buffer_dma_draw_hline>:

void alt_up_pixel_buffer_dma_draw_hline(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int x1, int y, int color, int backbuffer)
/* This method draws a horizontal line. This method is faster than using the line method because we know the direction of the line. */
{
   89ff8:	defff204 	addi	sp,sp,-56
   89ffc:	df000d15 	stw	fp,52(sp)
   8a000:	df000d04 	addi	fp,sp,52
   8a004:	e13ff315 	stw	r4,-52(fp)
   8a008:	e17ff415 	stw	r5,-48(fp)
   8a00c:	e1bff515 	stw	r6,-44(fp)
   8a010:	e1fff615 	stw	r7,-40(fp)
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
   8a014:	e0bff317 	ldw	r2,-52(fp)
   8a018:	10800f17 	ldw	r2,60(r2)
   8a01c:	e0bffe15 	stw	r2,-8(fp)
	register unsigned int limit_y = pixel_buffer->y_resolution;
   8a020:	e0bff317 	ldw	r2,-52(fp)
   8a024:	10801017 	ldw	r2,64(r2)
   8a028:	e0bffd15 	stw	r2,-12(fp)
	register unsigned int temp;
	register unsigned int l_x = x0;
   8a02c:	e0bff417 	ldw	r2,-48(fp)
   8a030:	e0bffc15 	stw	r2,-16(fp)
	register unsigned int r_x = x1;
   8a034:	e0fff517 	ldw	r3,-44(fp)
   8a038:	e0fffb15 	stw	r3,-20(fp)
	register unsigned int line_y = y;
   8a03c:	e13ff617 	ldw	r4,-40(fp)
   8a040:	e13ffa15 	stw	r4,-24(fp)
	register unsigned int local_color = color;
   8a044:	e0800117 	ldw	r2,4(fp)
   8a048:	e0bff915 	stw	r2,-28(fp)
	
	/* Check coordinates */
	if (l_x > r_x)
   8a04c:	e0fffb17 	ldw	r3,-20(fp)
   8a050:	e13ffc17 	ldw	r4,-16(fp)
   8a054:	1900042e 	bgeu	r3,r4,8a068 <alt_up_pixel_buffer_dma_draw_hline+0x70>
	{
		temp = l_x;
   8a058:	e0bffc17 	ldw	r2,-16(fp)
		l_x = r_x;
   8a05c:	e0fffb17 	ldw	r3,-20(fp)
   8a060:	e0fffc15 	stw	r3,-16(fp)
		r_x = temp;
   8a064:	e0bffb15 	stw	r2,-20(fp)
	}
	if ((l_x >= limit_x) || (line_y >= limit_y) || (r_x < 0) || (line_y < 0))
   8a068:	e13ffc17 	ldw	r4,-16(fp)
   8a06c:	e0bffe17 	ldw	r2,-8(fp)
   8a070:	2080b12e 	bgeu	r4,r2,8a338 <alt_up_pixel_buffer_dma_draw_hline+0x340>
   8a074:	e0fffa17 	ldw	r3,-24(fp)
   8a078:	e13ffd17 	ldw	r4,-12(fp)
   8a07c:	19000136 	bltu	r3,r4,8a084 <alt_up_pixel_buffer_dma_draw_hline+0x8c>
	{
		/* Drawing outside of the window, so don't bother. */
		return;
   8a080:	0000ad06 	br	8a338 <alt_up_pixel_buffer_dma_draw_hline+0x340>
	/* Clip the box and draw only within the confines of the screen. */
	if (l_x < 0)
	{
		l_x = 0;
	}
	if (r_x >= limit_x)
   8a084:	e0bffb17 	ldw	r2,-20(fp)
   8a088:	e0fffe17 	ldw	r3,-8(fp)
   8a08c:	10c00336 	bltu	r2,r3,8a09c <alt_up_pixel_buffer_dma_draw_hline+0xa4>
	{
		r_x = limit_x - 1;
   8a090:	e13ffe17 	ldw	r4,-8(fp)
   8a094:	213fffc4 	addi	r4,r4,-1
   8a098:	e13ffb15 	stw	r4,-20(fp)
	}

	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
   8a09c:	e0800217 	ldw	r2,8(fp)
   8a0a0:	10800058 	cmpnei	r2,r2,1
   8a0a4:	1000041e 	bne	r2,zero,8a0b8 <alt_up_pixel_buffer_dma_draw_hline+0xc0>
		addr = pixel_buffer->back_buffer_start_address;
   8a0a8:	e0bff317 	ldw	r2,-52(fp)
   8a0ac:	10800c17 	ldw	r2,48(r2)
   8a0b0:	e0bfff15 	stw	r2,-4(fp)
   8a0b4:	00000306 	br	8a0c4 <alt_up_pixel_buffer_dma_draw_hline+0xcc>
	else
		addr = pixel_buffer->buffer_start_address;
   8a0b8:	e0bff317 	ldw	r2,-52(fp)
   8a0bc:	10800b17 	ldw	r2,44(r2)
   8a0c0:	e0bfff15 	stw	r2,-4(fp)

	/* Draw a horizontal line using one of the addressing modes. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
   8a0c4:	e0bff317 	ldw	r2,-52(fp)
   8a0c8:	10800d17 	ldw	r2,52(r2)
   8a0cc:	1004c03a 	cmpne	r2,r2,zero
   8a0d0:	1000431e 	bne	r2,zero,8a1e0 <alt_up_pixel_buffer_dma_draw_hline+0x1e8>
		/* Draw a horizontal line of a given color on the screen using the XY addressing mode. */
		register unsigned int x;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
   8a0d4:	e0bff317 	ldw	r2,-52(fp)
   8a0d8:	10801317 	ldw	r2,76(r2)
		addr = addr + (line_y << offset_y);
   8a0dc:	e0fffa17 	ldw	r3,-24(fp)
   8a0e0:	1884983a 	sll	r2,r3,r2
   8a0e4:	e13fff17 	ldw	r4,-4(fp)
   8a0e8:	2089883a 	add	r4,r4,r2
   8a0ec:	e13fff15 	stw	r4,-4(fp)
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a horizontal line. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
   8a0f0:	e0bff317 	ldw	r2,-52(fp)
   8a0f4:	10800e17 	ldw	r2,56(r2)
   8a0f8:	10800058 	cmpnei	r2,r2,1
   8a0fc:	10000f1e 	bne	r2,zero,8a13c <alt_up_pixel_buffer_dma_draw_hline+0x144>
			for (x = l_x; x <= r_x; x++)
   8a100:	e0bffc17 	ldw	r2,-16(fp)
   8a104:	e0bff815 	stw	r2,-32(fp)
   8a108:	00000806 	br	8a12c <alt_up_pixel_buffer_dma_draw_hline+0x134>
			{
				IOWR_8DIRECT(addr, x, local_color);
   8a10c:	e0ffff17 	ldw	r3,-4(fp)
   8a110:	e0bff817 	ldw	r2,-32(fp)
   8a114:	1885883a 	add	r2,r3,r2
   8a118:	e0fff917 	ldw	r3,-28(fp)
   8a11c:	10c00025 	stbio	r3,0(r2)
		addr = addr + (line_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a horizontal line. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (x = l_x; x <= r_x; x++)
   8a120:	e0fff817 	ldw	r3,-32(fp)
   8a124:	18c00044 	addi	r3,r3,1
   8a128:	e0fff815 	stw	r3,-32(fp)
   8a12c:	e13ffb17 	ldw	r4,-20(fp)
   8a130:	e0bff817 	ldw	r2,-32(fp)
   8a134:	20bff52e 	bgeu	r4,r2,8a10c <alt_up_pixel_buffer_dma_draw_hline+0x114>
   8a138:	00007f06 	br	8a338 <alt_up_pixel_buffer_dma_draw_hline+0x340>
			{
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
   8a13c:	e0bff317 	ldw	r2,-52(fp)
   8a140:	10800e17 	ldw	r2,56(r2)
   8a144:	10800098 	cmpnei	r2,r2,2
   8a148:	1000121e 	bne	r2,zero,8a194 <alt_up_pixel_buffer_dma_draw_hline+0x19c>
			for (x = l_x; x <= r_x; x++)
   8a14c:	e0fffc17 	ldw	r3,-16(fp)
   8a150:	e0fff815 	stw	r3,-32(fp)
   8a154:	00000b06 	br	8a184 <alt_up_pixel_buffer_dma_draw_hline+0x18c>
			{
				IOWR_16DIRECT(addr, x << 1, local_color);
   8a158:	e13ff817 	ldw	r4,-32(fp)
   8a15c:	e13ff817 	ldw	r4,-32(fp)
   8a160:	2105883a 	add	r2,r4,r4
   8a164:	1007883a 	mov	r3,r2
   8a168:	e0bfff17 	ldw	r2,-4(fp)
   8a16c:	1885883a 	add	r2,r3,r2
   8a170:	e0fff917 	ldw	r3,-28(fp)
   8a174:	10c0002d 	sthio	r3,0(r2)
			for (x = l_x; x <= r_x; x++)
			{
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (x = l_x; x <= r_x; x++)
   8a178:	e0bff817 	ldw	r2,-32(fp)
   8a17c:	10800044 	addi	r2,r2,1
   8a180:	e0bff815 	stw	r2,-32(fp)
   8a184:	e0fffb17 	ldw	r3,-20(fp)
   8a188:	e13ff817 	ldw	r4,-32(fp)
   8a18c:	193ff22e 	bgeu	r3,r4,8a158 <alt_up_pixel_buffer_dma_draw_hline+0x160>
   8a190:	00006906 	br	8a338 <alt_up_pixel_buffer_dma_draw_hline+0x340>
				IOWR_16DIRECT(addr, x << 1, local_color);
			}
		}
		else
		{
			for (x = l_x; x <= r_x; x++)
   8a194:	e0bffc17 	ldw	r2,-16(fp)
   8a198:	e0bff815 	stw	r2,-32(fp)
   8a19c:	00000c06 	br	8a1d0 <alt_up_pixel_buffer_dma_draw_hline+0x1d8>
			{
				IOWR_32DIRECT(addr, x << 2, local_color);
   8a1a0:	e0fff817 	ldw	r3,-32(fp)
   8a1a4:	e0fff817 	ldw	r3,-32(fp)
   8a1a8:	18c5883a 	add	r2,r3,r3
   8a1ac:	1085883a 	add	r2,r2,r2
   8a1b0:	1007883a 	mov	r3,r2
   8a1b4:	e0bfff17 	ldw	r2,-4(fp)
   8a1b8:	1885883a 	add	r2,r3,r2
   8a1bc:	e0fff917 	ldw	r3,-28(fp)
   8a1c0:	10c00035 	stwio	r3,0(r2)
				IOWR_16DIRECT(addr, x << 1, local_color);
			}
		}
		else
		{
			for (x = l_x; x <= r_x; x++)
   8a1c4:	e13ff817 	ldw	r4,-32(fp)
   8a1c8:	21000044 	addi	r4,r4,1
   8a1cc:	e13ff815 	stw	r4,-32(fp)
   8a1d0:	e0bffb17 	ldw	r2,-20(fp)
   8a1d4:	e0fff817 	ldw	r3,-32(fp)
   8a1d8:	10fff12e 	bgeu	r2,r3,8a1a0 <alt_up_pixel_buffer_dma_draw_hline+0x1a8>
   8a1dc:	00005606 	br	8a338 <alt_up_pixel_buffer_dma_draw_hline+0x340>
	} else {
		/* Draw a horizontal line of a given color on the screen using the linear addressing mode. */
		register unsigned int x;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
   8a1e0:	e0bff317 	ldw	r2,-52(fp)
   8a1e4:	10800e17 	ldw	r2,56(r2)
   8a1e8:	10800058 	cmpnei	r2,r2,1
   8a1ec:	1000151e 	bne	r2,zero,8a244 <alt_up_pixel_buffer_dma_draw_hline+0x24c>
			addr = addr + line_y * limit_x;
   8a1f0:	e13ffa17 	ldw	r4,-24(fp)
   8a1f4:	e0fffe17 	ldw	r3,-8(fp)
   8a1f8:	20c5383a 	mul	r2,r4,r3
   8a1fc:	e13fff17 	ldw	r4,-4(fp)
   8a200:	2089883a 	add	r4,r4,r2
   8a204:	e13fff15 	stw	r4,-4(fp)
			for (x = l_x; x <= r_x; x++)
   8a208:	e0bffc17 	ldw	r2,-16(fp)
   8a20c:	e0bff715 	stw	r2,-36(fp)
   8a210:	00000806 	br	8a234 <alt_up_pixel_buffer_dma_draw_hline+0x23c>
			{
				IOWR_8DIRECT(addr, x, local_color);
   8a214:	e0ffff17 	ldw	r3,-4(fp)
   8a218:	e0bff717 	ldw	r2,-36(fp)
   8a21c:	1885883a 	add	r2,r3,r2
   8a220:	e0fff917 	ldw	r3,-28(fp)
   8a224:	10c00025 	stbio	r3,0(r2)
		register unsigned int x;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + line_y * limit_x;
			for (x = l_x; x <= r_x; x++)
   8a228:	e0fff717 	ldw	r3,-36(fp)
   8a22c:	18c00044 	addi	r3,r3,1
   8a230:	e0fff715 	stw	r3,-36(fp)
   8a234:	e13ffb17 	ldw	r4,-20(fp)
   8a238:	e0bff717 	ldw	r2,-36(fp)
   8a23c:	20bff52e 	bgeu	r4,r2,8a214 <alt_up_pixel_buffer_dma_draw_hline+0x21c>
   8a240:	00003d06 	br	8a338 <alt_up_pixel_buffer_dma_draw_hline+0x340>
			{
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
   8a244:	e0bff317 	ldw	r2,-52(fp)
   8a248:	10800e17 	ldw	r2,56(r2)
   8a24c:	10800098 	cmpnei	r2,r2,2
   8a250:	10001c1e 	bne	r2,zero,8a2c4 <alt_up_pixel_buffer_dma_draw_hline+0x2cc>
			limit_x = limit_x << 1;
   8a254:	e0fffe17 	ldw	r3,-8(fp)
   8a258:	e0fffe17 	ldw	r3,-8(fp)
   8a25c:	18c5883a 	add	r2,r3,r3
   8a260:	e0bffe15 	stw	r2,-8(fp)
			addr = addr + line_y * limit_x;
   8a264:	e13ffa17 	ldw	r4,-24(fp)
   8a268:	e0fffe17 	ldw	r3,-8(fp)
   8a26c:	20c5383a 	mul	r2,r4,r3
   8a270:	e13fff17 	ldw	r4,-4(fp)
   8a274:	2089883a 	add	r4,r4,r2
   8a278:	e13fff15 	stw	r4,-4(fp)
			for (x = l_x; x <= r_x; x++)
   8a27c:	e0bffc17 	ldw	r2,-16(fp)
   8a280:	e0bff715 	stw	r2,-36(fp)
   8a284:	00000b06 	br	8a2b4 <alt_up_pixel_buffer_dma_draw_hline+0x2bc>
			{
				IOWR_16DIRECT(addr, x << 1, local_color);
   8a288:	e0fff717 	ldw	r3,-36(fp)
   8a28c:	e0fff717 	ldw	r3,-36(fp)
   8a290:	18c5883a 	add	r2,r3,r3
   8a294:	1007883a 	mov	r3,r2
   8a298:	e0bfff17 	ldw	r2,-4(fp)
   8a29c:	1885883a 	add	r2,r3,r2
   8a2a0:	e0fff917 	ldw	r3,-28(fp)
   8a2a4:	10c0002d 	sthio	r3,0(r2)
				IOWR_8DIRECT(addr, x, local_color);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + line_y * limit_x;
			for (x = l_x; x <= r_x; x++)
   8a2a8:	e13ff717 	ldw	r4,-36(fp)
   8a2ac:	21000044 	addi	r4,r4,1
   8a2b0:	e13ff715 	stw	r4,-36(fp)
   8a2b4:	e0bffb17 	ldw	r2,-20(fp)
   8a2b8:	e0fff717 	ldw	r3,-36(fp)
   8a2bc:	10fff22e 	bgeu	r2,r3,8a288 <alt_up_pixel_buffer_dma_draw_hline+0x290>
   8a2c0:	00001d06 	br	8a338 <alt_up_pixel_buffer_dma_draw_hline+0x340>
				IOWR_16DIRECT(addr, x << 1, local_color);
			}
		}
		else
		{
			limit_x = limit_x << 2;
   8a2c4:	e13ffe17 	ldw	r4,-8(fp)
   8a2c8:	e13ffe17 	ldw	r4,-8(fp)
   8a2cc:	2105883a 	add	r2,r4,r4
   8a2d0:	1085883a 	add	r2,r2,r2
   8a2d4:	e0bffe15 	stw	r2,-8(fp)
			addr = addr + line_y * limit_x;
   8a2d8:	e0fffa17 	ldw	r3,-24(fp)
   8a2dc:	e13ffe17 	ldw	r4,-8(fp)
   8a2e0:	1905383a 	mul	r2,r3,r4
   8a2e4:	e0ffff17 	ldw	r3,-4(fp)
   8a2e8:	1887883a 	add	r3,r3,r2
   8a2ec:	e0ffff15 	stw	r3,-4(fp)
			for (x = l_x; x <= r_x; x++)
   8a2f0:	e13ffc17 	ldw	r4,-16(fp)
   8a2f4:	e13ff715 	stw	r4,-36(fp)
   8a2f8:	00000c06 	br	8a32c <alt_up_pixel_buffer_dma_draw_hline+0x334>
			{
				IOWR_32DIRECT(addr, x << 2, local_color);
   8a2fc:	e0fff717 	ldw	r3,-36(fp)
   8a300:	e0fff717 	ldw	r3,-36(fp)
   8a304:	18c5883a 	add	r2,r3,r3
   8a308:	1085883a 	add	r2,r2,r2
   8a30c:	1007883a 	mov	r3,r2
   8a310:	e0bfff17 	ldw	r2,-4(fp)
   8a314:	1885883a 	add	r2,r3,r2
   8a318:	e0fff917 	ldw	r3,-28(fp)
   8a31c:	10c00035 	stwio	r3,0(r2)
		}
		else
		{
			limit_x = limit_x << 2;
			addr = addr + line_y * limit_x;
			for (x = l_x; x <= r_x; x++)
   8a320:	e13ff717 	ldw	r4,-36(fp)
   8a324:	21000044 	addi	r4,r4,1
   8a328:	e13ff715 	stw	r4,-36(fp)
   8a32c:	e0bffb17 	ldw	r2,-20(fp)
   8a330:	e0fff717 	ldw	r3,-36(fp)
   8a334:	10fff12e 	bgeu	r2,r3,8a2fc <alt_up_pixel_buffer_dma_draw_hline+0x304>
				IOWR_32DIRECT(addr, x << 2, local_color);
			}
			addr = addr + limit_x;
		}
	}
}
   8a338:	e037883a 	mov	sp,fp
   8a33c:	df000017 	ldw	fp,0(sp)
   8a340:	dec00104 	addi	sp,sp,4
   8a344:	f800283a 	ret

0008a348 <alt_up_pixel_buffer_dma_draw_vline>:


void alt_up_pixel_buffer_dma_draw_vline(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x, int y0, int y1, int color, int backbuffer)
/* This method draws a vertical line. This method is faster than using the line method because we know the direction of the line. */

{
   8a348:	defff104 	addi	sp,sp,-60
   8a34c:	df000e15 	stw	fp,56(sp)
   8a350:	df000e04 	addi	fp,sp,56
   8a354:	e13ff215 	stw	r4,-56(fp)
   8a358:	e17ff315 	stw	r5,-52(fp)
   8a35c:	e1bff415 	stw	r6,-48(fp)
   8a360:	e1fff515 	stw	r7,-44(fp)
	register unsigned int addr;
	register unsigned int limit_x = pixel_buffer->x_resolution;
   8a364:	e0bff217 	ldw	r2,-56(fp)
   8a368:	10800f17 	ldw	r2,60(r2)
   8a36c:	e0bffe15 	stw	r2,-8(fp)
	register unsigned int limit_y = pixel_buffer->y_resolution;
   8a370:	e0bff217 	ldw	r2,-56(fp)
   8a374:	10801017 	ldw	r2,64(r2)
   8a378:	e0bffd15 	stw	r2,-12(fp)
	register unsigned int temp;
	register unsigned int line_x = x;
   8a37c:	e0bff317 	ldw	r2,-52(fp)
   8a380:	e0bffc15 	stw	r2,-16(fp)
	register unsigned int t_y = y0;
   8a384:	e0fff417 	ldw	r3,-48(fp)
   8a388:	e0fffb15 	stw	r3,-20(fp)
	register unsigned int b_y = y1;
   8a38c:	e13ff517 	ldw	r4,-44(fp)
   8a390:	e13ffa15 	stw	r4,-24(fp)
	register unsigned int local_color = color;
   8a394:	e0800117 	ldw	r2,4(fp)
   8a398:	e0bff915 	stw	r2,-28(fp)
	
	/* Check coordinates */
	if (t_y > b_y)
   8a39c:	e0fffa17 	ldw	r3,-24(fp)
   8a3a0:	e13ffb17 	ldw	r4,-20(fp)
   8a3a4:	1900042e 	bgeu	r3,r4,8a3b8 <alt_up_pixel_buffer_dma_draw_vline+0x70>
	{
		temp = t_y;
   8a3a8:	e0bffb17 	ldw	r2,-20(fp)
		t_y = b_y;
   8a3ac:	e0fffa17 	ldw	r3,-24(fp)
   8a3b0:	e0fffb15 	stw	r3,-20(fp)
		b_y = temp;
   8a3b4:	e0bffa15 	stw	r2,-24(fp)
	}
	if ((line_x >= limit_x) || (t_y >= limit_y) || (line_x < 0) || (b_y < 0))
   8a3b8:	e13ffc17 	ldw	r4,-16(fp)
   8a3bc:	e0bffe17 	ldw	r2,-8(fp)
   8a3c0:	2080d12e 	bgeu	r4,r2,8a708 <alt_up_pixel_buffer_dma_draw_vline+0x3c0>
   8a3c4:	e0fffb17 	ldw	r3,-20(fp)
   8a3c8:	e13ffd17 	ldw	r4,-12(fp)
   8a3cc:	19000136 	bltu	r3,r4,8a3d4 <alt_up_pixel_buffer_dma_draw_vline+0x8c>
	{
		/* Drawing outside of the window, so don't bother. */
		return;
   8a3d0:	0000cd06 	br	8a708 <alt_up_pixel_buffer_dma_draw_vline+0x3c0>
	/* Clip the box and draw only within the confines of the screen. */
	if (t_y < 0)
	{
		t_y = 0;
	}
	if (b_y >= limit_y)
   8a3d4:	e0bffa17 	ldw	r2,-24(fp)
   8a3d8:	e0fffd17 	ldw	r3,-12(fp)
   8a3dc:	10c00336 	bltu	r2,r3,8a3ec <alt_up_pixel_buffer_dma_draw_vline+0xa4>
	{
		b_y = limit_y - 1;
   8a3e0:	e13ffd17 	ldw	r4,-12(fp)
   8a3e4:	213fffc4 	addi	r4,r4,-1
   8a3e8:	e13ffa15 	stw	r4,-24(fp)
	}

	/* Set up the address to start clearing from and the screen boundaries. */
	if (backbuffer == 1)
   8a3ec:	e0800217 	ldw	r2,8(fp)
   8a3f0:	10800058 	cmpnei	r2,r2,1
   8a3f4:	1000041e 	bne	r2,zero,8a408 <alt_up_pixel_buffer_dma_draw_vline+0xc0>
		addr = pixel_buffer->back_buffer_start_address;
   8a3f8:	e0bff217 	ldw	r2,-56(fp)
   8a3fc:	10800c17 	ldw	r2,48(r2)
   8a400:	e0bfff15 	stw	r2,-4(fp)
   8a404:	00000306 	br	8a414 <alt_up_pixel_buffer_dma_draw_vline+0xcc>
	else
		addr = pixel_buffer->buffer_start_address;
   8a408:	e0bff217 	ldw	r2,-56(fp)
   8a40c:	10800b17 	ldw	r2,44(r2)
   8a410:	e0bfff15 	stw	r2,-4(fp)

	/* Draw the vertical line using one of the addressing modes. */
	if (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) {
   8a414:	e0bff217 	ldw	r2,-56(fp)
   8a418:	10800d17 	ldw	r2,52(r2)
   8a41c:	1004c03a 	cmpne	r2,r2,zero
   8a420:	1000571e 	bne	r2,zero,8a580 <alt_up_pixel_buffer_dma_draw_vline+0x238>
		/* Draw a vertical line of a given color on the screen using the XY addressing mode. */
		register unsigned int y;
		register unsigned int offset_y;
		offset_y = pixel_buffer->y_coord_offset;
   8a424:	e0bff217 	ldw	r2,-56(fp)
   8a428:	10801317 	ldw	r2,76(r2)
   8a42c:	e0bff715 	stw	r2,-36(fp)
		addr = addr + (t_y << offset_y);
   8a430:	e0bff717 	ldw	r2,-36(fp)
   8a434:	e0fffb17 	ldw	r3,-20(fp)
   8a438:	1884983a 	sll	r2,r3,r2
   8a43c:	e13fff17 	ldw	r4,-4(fp)
   8a440:	2089883a 	add	r4,r4,r2
   8a444:	e13fff15 	stw	r4,-4(fp)
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
   8a448:	e0bff217 	ldw	r2,-56(fp)
   8a44c:	10800e17 	ldw	r2,56(r2)
   8a450:	10800058 	cmpnei	r2,r2,1
   8a454:	1000151e 	bne	r2,zero,8a4ac <alt_up_pixel_buffer_dma_draw_vline+0x164>
			for (y = t_y; y <= b_y; y++)
   8a458:	e0bffb17 	ldw	r2,-20(fp)
   8a45c:	e0bff815 	stw	r2,-32(fp)
   8a460:	00000e06 	br	8a49c <alt_up_pixel_buffer_dma_draw_vline+0x154>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
   8a464:	e0ffff17 	ldw	r3,-4(fp)
   8a468:	e0bffc17 	ldw	r2,-16(fp)
   8a46c:	1885883a 	add	r2,r3,r2
   8a470:	e0fff917 	ldw	r3,-28(fp)
   8a474:	10c00025 	stbio	r3,0(r2)
				addr = addr + (1 << offset_y);
   8a478:	e0fff717 	ldw	r3,-36(fp)
   8a47c:	00800044 	movi	r2,1
   8a480:	10c4983a 	sll	r2,r2,r3
   8a484:	e0ffff17 	ldw	r3,-4(fp)
   8a488:	1887883a 	add	r3,r3,r2
   8a48c:	e0ffff15 	stw	r3,-4(fp)
		addr = addr + (t_y << offset_y);
		
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
   8a490:	e13ff817 	ldw	r4,-32(fp)
   8a494:	21000044 	addi	r4,r4,1
   8a498:	e13ff815 	stw	r4,-32(fp)
   8a49c:	e0bffa17 	ldw	r2,-24(fp)
   8a4a0:	e0fff817 	ldw	r3,-32(fp)
   8a4a4:	10ffef2e 	bgeu	r2,r3,8a464 <alt_up_pixel_buffer_dma_draw_vline+0x11c>
   8a4a8:	00009706 	br	8a708 <alt_up_pixel_buffer_dma_draw_vline+0x3c0>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
   8a4ac:	e0bff217 	ldw	r2,-56(fp)
   8a4b0:	10800e17 	ldw	r2,56(r2)
   8a4b4:	10800098 	cmpnei	r2,r2,2
   8a4b8:	1000181e 	bne	r2,zero,8a51c <alt_up_pixel_buffer_dma_draw_vline+0x1d4>
			for (y = t_y; y <= b_y; y++)
   8a4bc:	e13ffb17 	ldw	r4,-20(fp)
   8a4c0:	e13ff815 	stw	r4,-32(fp)
   8a4c4:	00001106 	br	8a50c <alt_up_pixel_buffer_dma_draw_vline+0x1c4>
			{
				IOWR_16DIRECT(addr, line_x << 1, local_color);
   8a4c8:	e0fffc17 	ldw	r3,-16(fp)
   8a4cc:	e0fffc17 	ldw	r3,-16(fp)
   8a4d0:	18c5883a 	add	r2,r3,r3
   8a4d4:	1007883a 	mov	r3,r2
   8a4d8:	e0bfff17 	ldw	r2,-4(fp)
   8a4dc:	1885883a 	add	r2,r3,r2
   8a4e0:	e0fff917 	ldw	r3,-28(fp)
   8a4e4:	10c0002d 	sthio	r3,0(r2)
				addr = addr + (1 << offset_y);
   8a4e8:	e0fff717 	ldw	r3,-36(fp)
   8a4ec:	00800044 	movi	r2,1
   8a4f0:	10c4983a 	sll	r2,r2,r3
   8a4f4:	e13fff17 	ldw	r4,-4(fp)
   8a4f8:	2089883a 	add	r4,r4,r2
   8a4fc:	e13fff15 	stw	r4,-4(fp)
			{
				IOWR_8DIRECT(addr, line_x, local_color);
				addr = addr + (1 << offset_y);
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			for (y = t_y; y <= b_y; y++)
   8a500:	e0bff817 	ldw	r2,-32(fp)
   8a504:	10800044 	addi	r2,r2,1
   8a508:	e0bff815 	stw	r2,-32(fp)
   8a50c:	e0fffa17 	ldw	r3,-24(fp)
   8a510:	e13ff817 	ldw	r4,-32(fp)
   8a514:	193fec2e 	bgeu	r3,r4,8a4c8 <alt_up_pixel_buffer_dma_draw_vline+0x180>
   8a518:	00007b06 	br	8a708 <alt_up_pixel_buffer_dma_draw_vline+0x3c0>
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
   8a51c:	e0bffb17 	ldw	r2,-20(fp)
   8a520:	e0bff815 	stw	r2,-32(fp)
   8a524:	00001206 	br	8a570 <alt_up_pixel_buffer_dma_draw_vline+0x228>
			{
				IOWR_32DIRECT(addr, line_x << 2, local_color);
   8a528:	e0fffc17 	ldw	r3,-16(fp)
   8a52c:	e0fffc17 	ldw	r3,-16(fp)
   8a530:	18c5883a 	add	r2,r3,r3
   8a534:	1085883a 	add	r2,r2,r2
   8a538:	1007883a 	mov	r3,r2
   8a53c:	e0bfff17 	ldw	r2,-4(fp)
   8a540:	1885883a 	add	r2,r3,r2
   8a544:	e0fff917 	ldw	r3,-28(fp)
   8a548:	10c00035 	stwio	r3,0(r2)
				addr = addr + (1 << offset_y);
   8a54c:	e0fff717 	ldw	r3,-36(fp)
   8a550:	00800044 	movi	r2,1
   8a554:	10c4983a 	sll	r2,r2,r3
   8a558:	e13fff17 	ldw	r4,-4(fp)
   8a55c:	2089883a 	add	r4,r4,r2
   8a560:	e13fff15 	stw	r4,-4(fp)
				addr = addr + (1 << offset_y);
			}
		}
		else
		{
			for (y = t_y; y <= b_y; y++)
   8a564:	e0bff817 	ldw	r2,-32(fp)
   8a568:	10800044 	addi	r2,r2,1
   8a56c:	e0bff815 	stw	r2,-32(fp)
   8a570:	e0fffa17 	ldw	r3,-24(fp)
   8a574:	e13ff817 	ldw	r4,-32(fp)
   8a578:	193feb2e 	bgeu	r3,r4,8a528 <alt_up_pixel_buffer_dma_draw_vline+0x1e0>
   8a57c:	00006206 	br	8a708 <alt_up_pixel_buffer_dma_draw_vline+0x3c0>
	} else {
		/* Draw a vertical line of a given color on the screen using the linear addressing mode. */
		register unsigned int y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
   8a580:	e0bff217 	ldw	r2,-56(fp)
   8a584:	10800e17 	ldw	r2,56(r2)
   8a588:	10800058 	cmpnei	r2,r2,1
   8a58c:	1000191e 	bne	r2,zero,8a5f4 <alt_up_pixel_buffer_dma_draw_vline+0x2ac>
			addr = addr + t_y * limit_x;
   8a590:	e0fffb17 	ldw	r3,-20(fp)
   8a594:	e13ffe17 	ldw	r4,-8(fp)
   8a598:	1905383a 	mul	r2,r3,r4
   8a59c:	e0ffff17 	ldw	r3,-4(fp)
   8a5a0:	1887883a 	add	r3,r3,r2
   8a5a4:	e0ffff15 	stw	r3,-4(fp)
			for (y = t_y; y <= b_y; y++)
   8a5a8:	e13ffb17 	ldw	r4,-20(fp)
   8a5ac:	e13ff615 	stw	r4,-40(fp)
   8a5b0:	00000c06 	br	8a5e4 <alt_up_pixel_buffer_dma_draw_vline+0x29c>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
   8a5b4:	e0ffff17 	ldw	r3,-4(fp)
   8a5b8:	e0bffc17 	ldw	r2,-16(fp)
   8a5bc:	1885883a 	add	r2,r3,r2
   8a5c0:	e0fff917 	ldw	r3,-28(fp)
   8a5c4:	10c00025 	stbio	r3,0(r2)
				addr = addr + limit_x;
   8a5c8:	e0bfff17 	ldw	r2,-4(fp)
   8a5cc:	e0fffe17 	ldw	r3,-8(fp)
   8a5d0:	10c5883a 	add	r2,r2,r3
   8a5d4:	e0bfff15 	stw	r2,-4(fp)
		register unsigned int y;
		/* This portion of the code is purposefully replicated. This is because having a text for
		 * the mode would unnecessarily slow down the drawing of a box. */
		if (pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) {
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
   8a5d8:	e13ff617 	ldw	r4,-40(fp)
   8a5dc:	21000044 	addi	r4,r4,1
   8a5e0:	e13ff615 	stw	r4,-40(fp)
   8a5e4:	e0bffa17 	ldw	r2,-24(fp)
   8a5e8:	e0fff617 	ldw	r3,-40(fp)
   8a5ec:	10fff12e 	bgeu	r2,r3,8a5b4 <alt_up_pixel_buffer_dma_draw_vline+0x26c>
   8a5f0:	00004506 	br	8a708 <alt_up_pixel_buffer_dma_draw_vline+0x3c0>
			{
				IOWR_8DIRECT(addr, line_x, local_color);
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
   8a5f4:	e0bff217 	ldw	r2,-56(fp)
   8a5f8:	10800e17 	ldw	r2,56(r2)
   8a5fc:	10800098 	cmpnei	r2,r2,2
   8a600:	1000201e 	bne	r2,zero,8a684 <alt_up_pixel_buffer_dma_draw_vline+0x33c>
			limit_x = limit_x << 1;
   8a604:	e13ffe17 	ldw	r4,-8(fp)
   8a608:	e13ffe17 	ldw	r4,-8(fp)
   8a60c:	2105883a 	add	r2,r4,r4
   8a610:	e0bffe15 	stw	r2,-8(fp)
			addr = addr + t_y * limit_x;
   8a614:	e0fffb17 	ldw	r3,-20(fp)
   8a618:	e13ffe17 	ldw	r4,-8(fp)
   8a61c:	1905383a 	mul	r2,r3,r4
   8a620:	e0ffff17 	ldw	r3,-4(fp)
   8a624:	1887883a 	add	r3,r3,r2
   8a628:	e0ffff15 	stw	r3,-4(fp)
			for (y = t_y; y <= b_y; y++)
   8a62c:	e13ffb17 	ldw	r4,-20(fp)
   8a630:	e13ff615 	stw	r4,-40(fp)
   8a634:	00000f06 	br	8a674 <alt_up_pixel_buffer_dma_draw_vline+0x32c>
			{
				IOWR_16DIRECT(addr, line_x << 1, local_color);
   8a638:	e0fffc17 	ldw	r3,-16(fp)
   8a63c:	e0fffc17 	ldw	r3,-16(fp)
   8a640:	18c5883a 	add	r2,r3,r3
   8a644:	1007883a 	mov	r3,r2
   8a648:	e0bfff17 	ldw	r2,-4(fp)
   8a64c:	1885883a 	add	r2,r3,r2
   8a650:	e0fff917 	ldw	r3,-28(fp)
   8a654:	10c0002d 	sthio	r3,0(r2)
				addr = addr + limit_x;
   8a658:	e13fff17 	ldw	r4,-4(fp)
   8a65c:	e0bffe17 	ldw	r2,-8(fp)
   8a660:	2089883a 	add	r4,r4,r2
   8a664:	e13fff15 	stw	r4,-4(fp)
				addr = addr + limit_x;
			}
		} else if (pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) {
			limit_x = limit_x << 1;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
   8a668:	e0fff617 	ldw	r3,-40(fp)
   8a66c:	18c00044 	addi	r3,r3,1
   8a670:	e0fff615 	stw	r3,-40(fp)
   8a674:	e13ffa17 	ldw	r4,-24(fp)
   8a678:	e0bff617 	ldw	r2,-40(fp)
   8a67c:	20bfee2e 	bgeu	r4,r2,8a638 <alt_up_pixel_buffer_dma_draw_vline+0x2f0>
   8a680:	00002106 	br	8a708 <alt_up_pixel_buffer_dma_draw_vline+0x3c0>
				addr = addr + limit_x;
			}
		}
		else
		{
			limit_x = limit_x << 2;
   8a684:	e0fffe17 	ldw	r3,-8(fp)
   8a688:	e0fffe17 	ldw	r3,-8(fp)
   8a68c:	18c5883a 	add	r2,r3,r3
   8a690:	1085883a 	add	r2,r2,r2
   8a694:	e0bffe15 	stw	r2,-8(fp)
			addr = addr + t_y * limit_x;
   8a698:	e13ffb17 	ldw	r4,-20(fp)
   8a69c:	e0fffe17 	ldw	r3,-8(fp)
   8a6a0:	20c5383a 	mul	r2,r4,r3
   8a6a4:	e13fff17 	ldw	r4,-4(fp)
   8a6a8:	2089883a 	add	r4,r4,r2
   8a6ac:	e13fff15 	stw	r4,-4(fp)
			for (y = t_y; y <= b_y; y++)
   8a6b0:	e0bffb17 	ldw	r2,-20(fp)
   8a6b4:	e0bff615 	stw	r2,-40(fp)
   8a6b8:	00001006 	br	8a6fc <alt_up_pixel_buffer_dma_draw_vline+0x3b4>
			{
				IOWR_32DIRECT(addr, line_x << 2, local_color);
   8a6bc:	e0fffc17 	ldw	r3,-16(fp)
   8a6c0:	e0fffc17 	ldw	r3,-16(fp)
   8a6c4:	18c5883a 	add	r2,r3,r3
   8a6c8:	1085883a 	add	r2,r2,r2
   8a6cc:	1007883a 	mov	r3,r2
   8a6d0:	e0bfff17 	ldw	r2,-4(fp)
   8a6d4:	1885883a 	add	r2,r3,r2
   8a6d8:	e0fff917 	ldw	r3,-28(fp)
   8a6dc:	10c00035 	stwio	r3,0(r2)
				addr = addr + limit_x;
   8a6e0:	e13fff17 	ldw	r4,-4(fp)
   8a6e4:	e0bffe17 	ldw	r2,-8(fp)
   8a6e8:	2089883a 	add	r4,r4,r2
   8a6ec:	e13fff15 	stw	r4,-4(fp)
		}
		else
		{
			limit_x = limit_x << 2;
			addr = addr + t_y * limit_x;
			for (y = t_y; y <= b_y; y++)
   8a6f0:	e0fff617 	ldw	r3,-40(fp)
   8a6f4:	18c00044 	addi	r3,r3,1
   8a6f8:	e0fff615 	stw	r3,-40(fp)
   8a6fc:	e13ffa17 	ldw	r4,-24(fp)
   8a700:	e0bff617 	ldw	r2,-40(fp)
   8a704:	20bfed2e 	bgeu	r4,r2,8a6bc <alt_up_pixel_buffer_dma_draw_vline+0x374>
				IOWR_32DIRECT(addr, line_x << 2, local_color);
				addr = addr + limit_x;
			}
		}
	}
}
   8a708:	e037883a 	mov	sp,fp
   8a70c:	df000017 	ldw	fp,0(sp)
   8a710:	dec00104 	addi	sp,sp,4
   8a714:	f800283a 	ret

0008a718 <alt_up_pixel_buffer_dma_draw_rectangle>:

void alt_up_pixel_buffer_dma_draw_rectangle(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
{
   8a718:	defff804 	addi	sp,sp,-32
   8a71c:	dfc00715 	stw	ra,28(sp)
   8a720:	df000615 	stw	fp,24(sp)
   8a724:	df000604 	addi	fp,sp,24
   8a728:	e13ffc15 	stw	r4,-16(fp)
   8a72c:	e17ffd15 	stw	r5,-12(fp)
   8a730:	e1bffe15 	stw	r6,-8(fp)
   8a734:	e1ffff15 	stw	r7,-4(fp)
	alt_up_pixel_buffer_dma_draw_hline(pixel_buffer, x0, x1, y0, color, backbuffer);
   8a738:	e0800317 	ldw	r2,12(fp)
   8a73c:	d8800015 	stw	r2,0(sp)
   8a740:	e0800417 	ldw	r2,16(fp)
   8a744:	d8800115 	stw	r2,4(sp)
   8a748:	e13ffc17 	ldw	r4,-16(fp)
   8a74c:	e17ffd17 	ldw	r5,-12(fp)
   8a750:	e1bfff17 	ldw	r6,-4(fp)
   8a754:	e1fffe17 	ldw	r7,-8(fp)
   8a758:	0089ff80 	call	89ff8 <alt_up_pixel_buffer_dma_draw_hline>
	alt_up_pixel_buffer_dma_draw_hline(pixel_buffer, x0, x1, y1, color, backbuffer);
   8a75c:	e0800317 	ldw	r2,12(fp)
   8a760:	d8800015 	stw	r2,0(sp)
   8a764:	e0800417 	ldw	r2,16(fp)
   8a768:	d8800115 	stw	r2,4(sp)
   8a76c:	e13ffc17 	ldw	r4,-16(fp)
   8a770:	e17ffd17 	ldw	r5,-12(fp)
   8a774:	e1bfff17 	ldw	r6,-4(fp)
   8a778:	e1c00217 	ldw	r7,8(fp)
   8a77c:	0089ff80 	call	89ff8 <alt_up_pixel_buffer_dma_draw_hline>
	alt_up_pixel_buffer_dma_draw_vline(pixel_buffer, x0, y0, y1, color, backbuffer);
   8a780:	e0800317 	ldw	r2,12(fp)
   8a784:	d8800015 	stw	r2,0(sp)
   8a788:	e0800417 	ldw	r2,16(fp)
   8a78c:	d8800115 	stw	r2,4(sp)
   8a790:	e13ffc17 	ldw	r4,-16(fp)
   8a794:	e17ffd17 	ldw	r5,-12(fp)
   8a798:	e1bffe17 	ldw	r6,-8(fp)
   8a79c:	e1c00217 	ldw	r7,8(fp)
   8a7a0:	008a3480 	call	8a348 <alt_up_pixel_buffer_dma_draw_vline>
	alt_up_pixel_buffer_dma_draw_vline(pixel_buffer, x1, y0, y1, color, backbuffer);
   8a7a4:	e0800317 	ldw	r2,12(fp)
   8a7a8:	d8800015 	stw	r2,0(sp)
   8a7ac:	e0800417 	ldw	r2,16(fp)
   8a7b0:	d8800115 	stw	r2,4(sp)
   8a7b4:	e13ffc17 	ldw	r4,-16(fp)
   8a7b8:	e17fff17 	ldw	r5,-4(fp)
   8a7bc:	e1bffe17 	ldw	r6,-8(fp)
   8a7c0:	e1c00217 	ldw	r7,8(fp)
   8a7c4:	008a3480 	call	8a348 <alt_up_pixel_buffer_dma_draw_vline>
}
   8a7c8:	e037883a 	mov	sp,fp
   8a7cc:	dfc00117 	ldw	ra,4(sp)
   8a7d0:	df000017 	ldw	fp,0(sp)
   8a7d4:	dec00204 	addi	sp,sp,8
   8a7d8:	f800283a 	ret

0008a7dc <helper_plot_pixel>:

void helper_plot_pixel(register unsigned int buffer_start, register int line_size, register int x, register int y, register int color, register int mode)
/* This is a helper function that draws a pixel at a given location. Note that no boundary checks are made,
 * so drawing off-screen may cause unpredictable side effects. */
{
   8a7dc:	defffb04 	addi	sp,sp,-20
   8a7e0:	df000415 	stw	fp,16(sp)
   8a7e4:	df000404 	addi	fp,sp,16
   8a7e8:	e13ffc15 	stw	r4,-16(fp)
   8a7ec:	e17ffd15 	stw	r5,-12(fp)
   8a7f0:	e1bffe15 	stw	r6,-8(fp)
   8a7f4:	e1ffff15 	stw	r7,-4(fp)
	if (mode == 0)
   8a7f8:	e0c00217 	ldw	r3,8(fp)
   8a7fc:	1804c03a 	cmpne	r2,r3,zero
   8a800:	10000b1e 	bne	r2,zero,8a830 <helper_plot_pixel+0x54>
		IOWR_8DIRECT(buffer_start, line_size*y+x, color);
   8a804:	e13ffd17 	ldw	r4,-12(fp)
   8a808:	e0ffff17 	ldw	r3,-4(fp)
   8a80c:	20c5383a 	mul	r2,r4,r3
   8a810:	e13ffe17 	ldw	r4,-8(fp)
   8a814:	1105883a 	add	r2,r2,r4
   8a818:	1007883a 	mov	r3,r2
   8a81c:	e0bffc17 	ldw	r2,-16(fp)
   8a820:	1885883a 	add	r2,r3,r2
   8a824:	e0c00117 	ldw	r3,4(fp)
   8a828:	10c00025 	stbio	r3,0(r2)
   8a82c:	00001b06 	br	8a89c <helper_plot_pixel+0xc0>
	else if (mode == 1)
   8a830:	e1000217 	ldw	r4,8(fp)
   8a834:	20800058 	cmpnei	r2,r4,1
   8a838:	10000c1e 	bne	r2,zero,8a86c <helper_plot_pixel+0x90>
		IOWR_16DIRECT(buffer_start, (line_size*y+x) << 1, color);
   8a83c:	e0fffd17 	ldw	r3,-12(fp)
   8a840:	e13fff17 	ldw	r4,-4(fp)
   8a844:	1905383a 	mul	r2,r3,r4
   8a848:	e0fffe17 	ldw	r3,-8(fp)
   8a84c:	10c5883a 	add	r2,r2,r3
   8a850:	1085883a 	add	r2,r2,r2
   8a854:	1007883a 	mov	r3,r2
   8a858:	e0bffc17 	ldw	r2,-16(fp)
   8a85c:	1885883a 	add	r2,r3,r2
   8a860:	e1000117 	ldw	r4,4(fp)
   8a864:	1100002d 	sthio	r4,0(r2)
   8a868:	00000c06 	br	8a89c <helper_plot_pixel+0xc0>
	else
		IOWR_32DIRECT(buffer_start, (line_size*y+x) << 2, color);
   8a86c:	e0fffd17 	ldw	r3,-12(fp)
   8a870:	e13fff17 	ldw	r4,-4(fp)
   8a874:	1905383a 	mul	r2,r3,r4
   8a878:	e0fffe17 	ldw	r3,-8(fp)
   8a87c:	10c5883a 	add	r2,r2,r3
   8a880:	1085883a 	add	r2,r2,r2
   8a884:	1085883a 	add	r2,r2,r2
   8a888:	1007883a 	mov	r3,r2
   8a88c:	e0bffc17 	ldw	r2,-16(fp)
   8a890:	1885883a 	add	r2,r3,r2
   8a894:	e1000117 	ldw	r4,4(fp)
   8a898:	11000035 	stwio	r4,0(r2)
}
   8a89c:	e037883a 	mov	sp,fp
   8a8a0:	df000017 	ldw	fp,0(sp)
   8a8a4:	dec00104 	addi	sp,sp,4
   8a8a8:	f800283a 	ret

0008a8ac <alt_up_pixel_buffer_dma_draw_line>:

void alt_up_pixel_buffer_dma_draw_line(alt_up_pixel_buffer_dma_dev *pixel_buffer, int x0, int y0, int x1, int y1, int color, int backbuffer)
/* This function draws a line between points (x0, y0) and (x1, y1). The function does not check if it draws a pixel within screen boundaries.
 * users should ensure that the line is drawn within the screen boundaries. */
{
   8a8ac:	deffe404 	addi	sp,sp,-112
   8a8b0:	dfc01b15 	stw	ra,108(sp)
   8a8b4:	df001a15 	stw	fp,104(sp)
   8a8b8:	df001a04 	addi	fp,sp,104
   8a8bc:	e13fe815 	stw	r4,-96(fp)
   8a8c0:	e17fe915 	stw	r5,-92(fp)
   8a8c4:	e1bfea15 	stw	r6,-88(fp)
   8a8c8:	e1ffeb15 	stw	r7,-84(fp)
	register int x_0 = x0;
   8a8cc:	e0bfe917 	ldw	r2,-92(fp)
   8a8d0:	e0bffa15 	stw	r2,-24(fp)
	register int y_0 = y0;
   8a8d4:	e0ffea17 	ldw	r3,-88(fp)
   8a8d8:	e0fff915 	stw	r3,-28(fp)
	register int x_1 = x1;
   8a8dc:	e13feb17 	ldw	r4,-84(fp)
   8a8e0:	e13ff815 	stw	r4,-32(fp)
	register int y_1 = y1;
   8a8e4:	e0800217 	ldw	r2,8(fp)
   8a8e8:	e0bff715 	stw	r2,-36(fp)
	register char steep = (ABS(y_1 - y_0) > ABS(x_1 - x_0)) ? 1 : 0;
   8a8ec:	e0fff717 	ldw	r3,-36(fp)
   8a8f0:	e13ff917 	ldw	r4,-28(fp)
   8a8f4:	1905c83a 	sub	r2,r3,r4
   8a8f8:	e0bfff15 	stw	r2,-4(fp)
   8a8fc:	e0ffff17 	ldw	r3,-4(fp)
   8a900:	1804403a 	cmpge	r2,r3,zero
   8a904:	1000031e 	bne	r2,zero,8a914 <alt_up_pixel_buffer_dma_draw_line+0x68>
   8a908:	e13fff17 	ldw	r4,-4(fp)
   8a90c:	0109c83a 	sub	r4,zero,r4
   8a910:	e13fff15 	stw	r4,-4(fp)
   8a914:	e0fff817 	ldw	r3,-32(fp)
   8a918:	e13ffa17 	ldw	r4,-24(fp)
   8a91c:	1905c83a 	sub	r2,r3,r4
   8a920:	e0bffe15 	stw	r2,-8(fp)
   8a924:	e0fffe17 	ldw	r3,-8(fp)
   8a928:	1804403a 	cmpge	r2,r3,zero
   8a92c:	1000031e 	bne	r2,zero,8a93c <alt_up_pixel_buffer_dma_draw_line+0x90>
   8a930:	e13ffe17 	ldw	r4,-8(fp)
   8a934:	0109c83a 	sub	r4,zero,r4
   8a938:	e13ffe15 	stw	r4,-8(fp)
   8a93c:	e0fffe17 	ldw	r3,-8(fp)
   8a940:	e13fff17 	ldw	r4,-4(fp)
   8a944:	1904803a 	cmplt	r2,r3,r4
   8a948:	e0bff605 	stb	r2,-40(fp)
	register int deltax, deltay, error, ystep, x, y;
	register int color_mode =	(pixel_buffer->color_mode == ALT_UP_8BIT_COLOR_MODE) ? 0 :
								(pixel_buffer->color_mode == ALT_UP_16BIT_COLOR_MODE) ? 1 : 2;
   8a94c:	e0bfe817 	ldw	r2,-96(fp)
   8a950:	10800e17 	ldw	r2,56(r2)
   8a954:	10800060 	cmpeqi	r2,r2,1
   8a958:	10000c1e 	bne	r2,zero,8a98c <alt_up_pixel_buffer_dma_draw_line+0xe0>
   8a95c:	e0bfe817 	ldw	r2,-96(fp)
   8a960:	10800e17 	ldw	r2,56(r2)
   8a964:	10800098 	cmpnei	r2,r2,2
   8a968:	1000031e 	bne	r2,zero,8a978 <alt_up_pixel_buffer_dma_draw_line+0xcc>
   8a96c:	00800044 	movi	r2,1
   8a970:	e0bffc15 	stw	r2,-16(fp)
   8a974:	00000206 	br	8a980 <alt_up_pixel_buffer_dma_draw_line+0xd4>
   8a978:	00c00084 	movi	r3,2
   8a97c:	e0fffc15 	stw	r3,-16(fp)
   8a980:	e13ffc17 	ldw	r4,-16(fp)
   8a984:	e13ffd15 	stw	r4,-12(fp)
   8a988:	00000106 	br	8a990 <alt_up_pixel_buffer_dma_draw_line+0xe4>
   8a98c:	e03ffd15 	stw	zero,-12(fp)
   8a990:	e0bffd17 	ldw	r2,-12(fp)
   8a994:	e0bfef15 	stw	r2,-68(fp)
	register int line_color = color;
   8a998:	e0c00317 	ldw	r3,12(fp)
   8a99c:	e0ffee15 	stw	r3,-72(fp)
	register unsigned int buffer_start;
	register int line_size = (pixel_buffer->addressing_mode == ALT_UP_PIXEL_BUFFER_XY_ADDRESS_MODE) ? (1 << (pixel_buffer->y_coord_offset-color_mode)) : pixel_buffer->x_resolution;
   8a9a0:	e0bfe817 	ldw	r2,-96(fp)
   8a9a4:	10800d17 	ldw	r2,52(r2)
   8a9a8:	1004c03a 	cmpne	r2,r2,zero
   8a9ac:	1000091e 	bne	r2,zero,8a9d4 <alt_up_pixel_buffer_dma_draw_line+0x128>
   8a9b0:	e0bfe817 	ldw	r2,-96(fp)
   8a9b4:	10c01317 	ldw	r3,76(r2)
   8a9b8:	e0bfef17 	ldw	r2,-68(fp)
   8a9bc:	1885c83a 	sub	r2,r3,r2
   8a9c0:	1007883a 	mov	r3,r2
   8a9c4:	00800044 	movi	r2,1
   8a9c8:	10c4983a 	sll	r2,r2,r3
   8a9cc:	e0bffb15 	stw	r2,-20(fp)
   8a9d0:	00000306 	br	8a9e0 <alt_up_pixel_buffer_dma_draw_line+0x134>
   8a9d4:	e0bfe817 	ldw	r2,-96(fp)
   8a9d8:	10800f17 	ldw	r2,60(r2)
   8a9dc:	e0bffb15 	stw	r2,-20(fp)
   8a9e0:	e13ffb17 	ldw	r4,-20(fp)
   8a9e4:	e13fec15 	stw	r4,-80(fp)

	if (backbuffer == 1)
   8a9e8:	e0800417 	ldw	r2,16(fp)
   8a9ec:	10800058 	cmpnei	r2,r2,1
   8a9f0:	1000041e 	bne	r2,zero,8aa04 <alt_up_pixel_buffer_dma_draw_line+0x158>
		buffer_start = pixel_buffer->back_buffer_start_address;
   8a9f4:	e0bfe817 	ldw	r2,-96(fp)
   8a9f8:	10800c17 	ldw	r2,48(r2)
   8a9fc:	e0bfed15 	stw	r2,-76(fp)
   8aa00:	00000306 	br	8aa10 <alt_up_pixel_buffer_dma_draw_line+0x164>
	else
		buffer_start = pixel_buffer->buffer_start_address;
   8aa04:	e0bfe817 	ldw	r2,-96(fp)
   8aa08:	10800b17 	ldw	r2,44(r2)
   8aa0c:	e0bfed15 	stw	r2,-76(fp)

	/* Preprocessing inputs */
	if (steep > 0) {
   8aa10:	e0fff603 	ldbu	r3,-40(fp)
   8aa14:	18803fcc 	andi	r2,r3,255
   8aa18:	1080201c 	xori	r2,r2,128
   8aa1c:	10bfe004 	addi	r2,r2,-128
   8aa20:	10800050 	cmplti	r2,r2,1
   8aa24:	10000c1e 	bne	r2,zero,8aa58 <alt_up_pixel_buffer_dma_draw_line+0x1ac>
		// Swap x_0 and y_0
		error = x_0;
   8aa28:	e13ffa17 	ldw	r4,-24(fp)
   8aa2c:	e13ff315 	stw	r4,-52(fp)
		x_0 = y_0;
   8aa30:	e0bff917 	ldw	r2,-28(fp)
   8aa34:	e0bffa15 	stw	r2,-24(fp)
		y_0 = error;
   8aa38:	e0fff317 	ldw	r3,-52(fp)
   8aa3c:	e0fff915 	stw	r3,-28(fp)
		// Swap x_1 and y_1
		error = x_1;
   8aa40:	e13ff817 	ldw	r4,-32(fp)
   8aa44:	e13ff315 	stw	r4,-52(fp)
		x_1 = y_1;
   8aa48:	e0bff717 	ldw	r2,-36(fp)
   8aa4c:	e0bff815 	stw	r2,-32(fp)
		y_1 = error;
   8aa50:	e0fff317 	ldw	r3,-52(fp)
   8aa54:	e0fff715 	stw	r3,-36(fp)
	}
	if (x_0 > x_1) {
   8aa58:	e13ff817 	ldw	r4,-32(fp)
   8aa5c:	e0bffa17 	ldw	r2,-24(fp)
   8aa60:	20800c0e 	bge	r4,r2,8aa94 <alt_up_pixel_buffer_dma_draw_line+0x1e8>
		// Swap x_0 and x_1
		error = x_0;
   8aa64:	e0fffa17 	ldw	r3,-24(fp)
   8aa68:	e0fff315 	stw	r3,-52(fp)
		x_0 = x_1;
   8aa6c:	e13ff817 	ldw	r4,-32(fp)
   8aa70:	e13ffa15 	stw	r4,-24(fp)
		x_1 = error;
   8aa74:	e0bff317 	ldw	r2,-52(fp)
   8aa78:	e0bff815 	stw	r2,-32(fp)
		// Swap y_0 and y_1
		error = y_0;
   8aa7c:	e0fff917 	ldw	r3,-28(fp)
   8aa80:	e0fff315 	stw	r3,-52(fp)
		y_0 = y_1;
   8aa84:	e13ff717 	ldw	r4,-36(fp)
   8aa88:	e13ff915 	stw	r4,-28(fp)
		y_1 = error;
   8aa8c:	e0bff317 	ldw	r2,-52(fp)
   8aa90:	e0bff715 	stw	r2,-36(fp)
	}

	/* Setup local variables */
	deltax = x_1 - x_0;
   8aa94:	e0fff817 	ldw	r3,-32(fp)
   8aa98:	e13ffa17 	ldw	r4,-24(fp)
   8aa9c:	1907c83a 	sub	r3,r3,r4
   8aaa0:	e0fff515 	stw	r3,-44(fp)
	deltay = ABS(y_1 - y_0);
   8aaa4:	e0fff717 	ldw	r3,-36(fp)
   8aaa8:	e13ff917 	ldw	r4,-28(fp)
   8aaac:	1905c83a 	sub	r2,r3,r4
   8aab0:	e0bff415 	stw	r2,-48(fp)
   8aab4:	e0fff417 	ldw	r3,-48(fp)
   8aab8:	1804403a 	cmpge	r2,r3,zero
   8aabc:	1000031e 	bne	r2,zero,8aacc <alt_up_pixel_buffer_dma_draw_line+0x220>
   8aac0:	e13ff417 	ldw	r4,-48(fp)
   8aac4:	0109c83a 	sub	r4,zero,r4
   8aac8:	e13ff415 	stw	r4,-48(fp)
	error = -(deltax / 2); 
   8aacc:	e0fff517 	ldw	r3,-44(fp)
   8aad0:	1804d7fa 	srli	r2,r3,31
   8aad4:	e13ff517 	ldw	r4,-44(fp)
   8aad8:	1105883a 	add	r2,r2,r4
   8aadc:	1005d07a 	srai	r2,r2,1
   8aae0:	0085c83a 	sub	r2,zero,r2
   8aae4:	e0bff315 	stw	r2,-52(fp)
	y = y_0;
   8aae8:	e0bff917 	ldw	r2,-28(fp)
   8aaec:	e0bff015 	stw	r2,-64(fp)
	if (y_0 < y_1)
   8aaf0:	e0fff917 	ldw	r3,-28(fp)
   8aaf4:	e13ff717 	ldw	r4,-36(fp)
   8aaf8:	1900030e 	bge	r3,r4,8ab08 <alt_up_pixel_buffer_dma_draw_line+0x25c>
		ystep = 1;
   8aafc:	00800044 	movi	r2,1
   8ab00:	e0bff215 	stw	r2,-56(fp)
   8ab04:	00000206 	br	8ab10 <alt_up_pixel_buffer_dma_draw_line+0x264>
	else
		ystep = -1;
   8ab08:	00ffffc4 	movi	r3,-1
   8ab0c:	e0fff215 	stw	r3,-56(fp)

	/* Draw a line - either go along the x axis (steep = 0) or along the y axis (steep = 1). The code is replicated to
	 * compile well on low optimization levels. */
	if (steep == 1)
   8ab10:	e13ff603 	ldbu	r4,-40(fp)
   8ab14:	20803fcc 	andi	r2,r4,255
   8ab18:	1080201c 	xori	r2,r2,128
   8ab1c:	10bfe004 	addi	r2,r2,-128
   8ab20:	10800058 	cmpnei	r2,r2,1
   8ab24:	1000221e 	bne	r2,zero,8abb0 <alt_up_pixel_buffer_dma_draw_line+0x304>
	{
		for (x=x_0; x <= x_1; x++) {
   8ab28:	e0bffa17 	ldw	r2,-24(fp)
   8ab2c:	e0bff115 	stw	r2,-60(fp)
   8ab30:	00001b06 	br	8aba0 <alt_up_pixel_buffer_dma_draw_line+0x2f4>
			helper_plot_pixel(buffer_start, line_size, y, x, line_color, color_mode);
   8ab34:	e0ffee17 	ldw	r3,-72(fp)
   8ab38:	d8c00015 	stw	r3,0(sp)
   8ab3c:	e13fef17 	ldw	r4,-68(fp)
   8ab40:	d9000115 	stw	r4,4(sp)
   8ab44:	e13fed17 	ldw	r4,-76(fp)
   8ab48:	e17fec17 	ldw	r5,-80(fp)
   8ab4c:	e1bff017 	ldw	r6,-64(fp)
   8ab50:	e1fff117 	ldw	r7,-60(fp)
   8ab54:	008a7dc0 	call	8a7dc <helper_plot_pixel>
			error = error + deltay;
   8ab58:	e0bff317 	ldw	r2,-52(fp)
   8ab5c:	e0fff417 	ldw	r3,-48(fp)
   8ab60:	10c5883a 	add	r2,r2,r3
   8ab64:	e0bff315 	stw	r2,-52(fp)
			if (error > 0) {
   8ab68:	e13ff317 	ldw	r4,-52(fp)
   8ab6c:	20800050 	cmplti	r2,r4,1
   8ab70:	1000081e 	bne	r2,zero,8ab94 <alt_up_pixel_buffer_dma_draw_line+0x2e8>
				y = y + ystep;
   8ab74:	e0bff017 	ldw	r2,-64(fp)
   8ab78:	e0fff217 	ldw	r3,-56(fp)
   8ab7c:	10c5883a 	add	r2,r2,r3
   8ab80:	e0bff015 	stw	r2,-64(fp)
				error = error - deltax;
   8ab84:	e13ff317 	ldw	r4,-52(fp)
   8ab88:	e0bff517 	ldw	r2,-44(fp)
   8ab8c:	2089c83a 	sub	r4,r4,r2
   8ab90:	e13ff315 	stw	r4,-52(fp)

	/* Draw a line - either go along the x axis (steep = 0) or along the y axis (steep = 1). The code is replicated to
	 * compile well on low optimization levels. */
	if (steep == 1)
	{
		for (x=x_0; x <= x_1; x++) {
   8ab94:	e0fff117 	ldw	r3,-60(fp)
   8ab98:	18c00044 	addi	r3,r3,1
   8ab9c:	e0fff115 	stw	r3,-60(fp)
   8aba0:	e13ff817 	ldw	r4,-32(fp)
   8aba4:	e0bff117 	ldw	r2,-60(fp)
   8aba8:	20bfe20e 	bge	r4,r2,8ab34 <alt_up_pixel_buffer_dma_draw_line+0x288>
   8abac:	00002106 	br	8ac34 <alt_up_pixel_buffer_dma_draw_line+0x388>
			}
		}
	}
	else
	{
		for (x=x_0; x <= x_1; x++) {
   8abb0:	e0fffa17 	ldw	r3,-24(fp)
   8abb4:	e0fff115 	stw	r3,-60(fp)
   8abb8:	00001b06 	br	8ac28 <alt_up_pixel_buffer_dma_draw_line+0x37c>
			helper_plot_pixel(buffer_start, line_size, x, y, line_color, color_mode);
   8abbc:	e13fee17 	ldw	r4,-72(fp)
   8abc0:	d9000015 	stw	r4,0(sp)
   8abc4:	e0bfef17 	ldw	r2,-68(fp)
   8abc8:	d8800115 	stw	r2,4(sp)
   8abcc:	e13fed17 	ldw	r4,-76(fp)
   8abd0:	e17fec17 	ldw	r5,-80(fp)
   8abd4:	e1bff117 	ldw	r6,-60(fp)
   8abd8:	e1fff017 	ldw	r7,-64(fp)
   8abdc:	008a7dc0 	call	8a7dc <helper_plot_pixel>
			error = error + deltay;
   8abe0:	e0fff317 	ldw	r3,-52(fp)
   8abe4:	e13ff417 	ldw	r4,-48(fp)
   8abe8:	1907883a 	add	r3,r3,r4
   8abec:	e0fff315 	stw	r3,-52(fp)
			if (error > 0) {
   8abf0:	e0fff317 	ldw	r3,-52(fp)
   8abf4:	18800050 	cmplti	r2,r3,1
   8abf8:	1000081e 	bne	r2,zero,8ac1c <alt_up_pixel_buffer_dma_draw_line+0x370>
				y = y + ystep;
   8abfc:	e13ff017 	ldw	r4,-64(fp)
   8ac00:	e0bff217 	ldw	r2,-56(fp)
   8ac04:	2089883a 	add	r4,r4,r2
   8ac08:	e13ff015 	stw	r4,-64(fp)
				error = error - deltax;
   8ac0c:	e0fff317 	ldw	r3,-52(fp)
   8ac10:	e13ff517 	ldw	r4,-44(fp)
   8ac14:	1907c83a 	sub	r3,r3,r4
   8ac18:	e0fff315 	stw	r3,-52(fp)
			}
		}
	}
	else
	{
		for (x=x_0; x <= x_1; x++) {
   8ac1c:	e0bff117 	ldw	r2,-60(fp)
   8ac20:	10800044 	addi	r2,r2,1
   8ac24:	e0bff115 	stw	r2,-60(fp)
   8ac28:	e0fff817 	ldw	r3,-32(fp)
   8ac2c:	e13ff117 	ldw	r4,-60(fp)
   8ac30:	193fe20e 	bge	r3,r4,8abbc <alt_up_pixel_buffer_dma_draw_line+0x310>
				y = y + ystep;
				error = error - deltax;
			}
		}
	}
}
   8ac34:	e037883a 	mov	sp,fp
   8ac38:	dfc00117 	ldw	ra,4(sp)
   8ac3c:	df000017 	ldw	fp,0(sp)
   8ac40:	dec00204 	addi	sp,sp,8
   8ac44:	f800283a 	ret

0008ac48 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   8ac48:	defffa04 	addi	sp,sp,-24
   8ac4c:	dfc00515 	stw	ra,20(sp)
   8ac50:	df000415 	stw	fp,16(sp)
   8ac54:	df000404 	addi	fp,sp,16
   8ac58:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
   8ac5c:	008000c4 	movi	r2,3
   8ac60:	e0bffc15 	stw	r2,-16(fp)
  }
  

  big_loops = us / (INT_MAX/
   8ac64:	e0fffc17 	ldw	r3,-16(fp)
   8ac68:	008003f4 	movhi	r2,15
   8ac6c:	10909004 	addi	r2,r2,16960
   8ac70:	188b383a 	mul	r5,r3,r2
   8ac74:	0100bef4 	movhi	r4,763
   8ac78:	213c2004 	addi	r4,r4,-3968
   8ac7c:	008b5980 	call	8b598 <__udivsi3>
   8ac80:	100b883a 	mov	r5,r2
   8ac84:	01200034 	movhi	r4,32768
   8ac88:	213fffc4 	addi	r4,r4,-1
   8ac8c:	008b5980 	call	8b598 <__udivsi3>
   8ac90:	100b883a 	mov	r5,r2
   8ac94:	e13fff17 	ldw	r4,-4(fp)
   8ac98:	008b5980 	call	8b598 <__udivsi3>
   8ac9c:	e0bffd15 	stw	r2,-12(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
   8aca0:	e0bffd17 	ldw	r2,-12(fp)
   8aca4:	1005003a 	cmpeq	r2,r2,zero
   8aca8:	1000281e 	bne	r2,zero,8ad4c <alt_busy_sleep+0x104>
  {
    for(i=0;i<big_loops;i++)
   8acac:	e03ffe15 	stw	zero,-8(fp)
   8acb0:	00001606 	br	8ad0c <alt_busy_sleep+0xc4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   8acb4:	00a00034 	movhi	r2,32768
   8acb8:	10bfffc4 	addi	r2,r2,-1
   8acbc:	10bfffc4 	addi	r2,r2,-1
   8acc0:	103ffe1e 	bne	r2,zero,8acbc <alt_busy_sleep+0x74>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
   8acc4:	e0fffc17 	ldw	r3,-16(fp)
   8acc8:	008003f4 	movhi	r2,15
   8accc:	10909004 	addi	r2,r2,16960
   8acd0:	188b383a 	mul	r5,r3,r2
   8acd4:	0100bef4 	movhi	r4,763
   8acd8:	213c2004 	addi	r4,r4,-3968
   8acdc:	008b5980 	call	8b598 <__udivsi3>
   8ace0:	100b883a 	mov	r5,r2
   8ace4:	01200034 	movhi	r4,32768
   8ace8:	213fffc4 	addi	r4,r4,-1
   8acec:	008b5980 	call	8b598 <__udivsi3>
   8acf0:	1007883a 	mov	r3,r2
   8acf4:	e0bfff17 	ldw	r2,-4(fp)
   8acf8:	10c5c83a 	sub	r2,r2,r3
   8acfc:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
   8ad00:	e0bffe17 	ldw	r2,-8(fp)
   8ad04:	10800044 	addi	r2,r2,1
   8ad08:	e0bffe15 	stw	r2,-8(fp)
   8ad0c:	e0fffe17 	ldw	r3,-8(fp)
   8ad10:	e0bffd17 	ldw	r2,-12(fp)
   8ad14:	18bfe716 	blt	r3,r2,8acb4 <alt_busy_sleep+0x6c>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   8ad18:	e0fffc17 	ldw	r3,-16(fp)
   8ad1c:	008003f4 	movhi	r2,15
   8ad20:	10909004 	addi	r2,r2,16960
   8ad24:	188b383a 	mul	r5,r3,r2
   8ad28:	0100bef4 	movhi	r4,763
   8ad2c:	213c2004 	addi	r4,r4,-3968
   8ad30:	008b5980 	call	8b598 <__udivsi3>
   8ad34:	1007883a 	mov	r3,r2
   8ad38:	e0bfff17 	ldw	r2,-4(fp)
   8ad3c:	1885383a 	mul	r2,r3,r2
   8ad40:	10bfffc4 	addi	r2,r2,-1
   8ad44:	103ffe1e 	bne	r2,zero,8ad40 <alt_busy_sleep+0xf8>
   8ad48:	00000c06 	br	8ad7c <alt_busy_sleep+0x134>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   8ad4c:	e0fffc17 	ldw	r3,-16(fp)
   8ad50:	008003f4 	movhi	r2,15
   8ad54:	10909004 	addi	r2,r2,16960
   8ad58:	188b383a 	mul	r5,r3,r2
   8ad5c:	0100bef4 	movhi	r4,763
   8ad60:	213c2004 	addi	r4,r4,-3968
   8ad64:	008b5980 	call	8b598 <__udivsi3>
   8ad68:	1007883a 	mov	r3,r2
   8ad6c:	e0bfff17 	ldw	r2,-4(fp)
   8ad70:	1885383a 	mul	r2,r3,r2
   8ad74:	10bfffc4 	addi	r2,r2,-1
   8ad78:	00bffe16 	blt	zero,r2,8ad74 <alt_busy_sleep+0x12c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
   8ad7c:	0005883a 	mov	r2,zero
}
   8ad80:	e037883a 	mov	sp,fp
   8ad84:	dfc00117 	ldw	ra,4(sp)
   8ad88:	df000017 	ldw	fp,0(sp)
   8ad8c:	dec00204 	addi	sp,sp,8
   8ad90:	f800283a 	ret

0008ad94 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
   8ad94:	defff804 	addi	sp,sp,-32
   8ad98:	dfc00715 	stw	ra,28(sp)
   8ad9c:	df000615 	stw	fp,24(sp)
   8ada0:	df000604 	addi	fp,sp,24
   8ada4:	e13ffc15 	stw	r4,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
   8ada8:	e0bffc17 	ldw	r2,-16(fp)
   8adac:	1004803a 	cmplt	r2,r2,zero
   8adb0:	1000081e 	bne	r2,zero,8add4 <close+0x40>
   8adb4:	e0bffc17 	ldw	r2,-16(fp)
   8adb8:	10800324 	muli	r2,r2,12
   8adbc:	1007883a 	mov	r3,r2
   8adc0:	00800274 	movhi	r2,9
   8adc4:	10adc104 	addi	r2,r2,-18684
   8adc8:	1887883a 	add	r3,r3,r2
   8adcc:	e0ffff15 	stw	r3,-4(fp)
   8add0:	00000106 	br	8add8 <close+0x44>
   8add4:	e03fff15 	stw	zero,-4(fp)
   8add8:	e0bfff17 	ldw	r2,-4(fp)
   8addc:	e0bffb15 	stw	r2,-20(fp)

  if (fd)
   8ade0:	e0bffb17 	ldw	r2,-20(fp)
   8ade4:	1005003a 	cmpeq	r2,r2,zero
   8ade8:	10001d1e 	bne	r2,zero,8ae60 <close+0xcc>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
   8adec:	e0bffb17 	ldw	r2,-20(fp)
   8adf0:	10800017 	ldw	r2,0(r2)
   8adf4:	10800417 	ldw	r2,16(r2)
   8adf8:	1005003a 	cmpeq	r2,r2,zero
   8adfc:	1000071e 	bne	r2,zero,8ae1c <close+0x88>
   8ae00:	e0bffb17 	ldw	r2,-20(fp)
   8ae04:	10800017 	ldw	r2,0(r2)
   8ae08:	10800417 	ldw	r2,16(r2)
   8ae0c:	e13ffb17 	ldw	r4,-20(fp)
   8ae10:	103ee83a 	callr	r2
   8ae14:	e0bffe15 	stw	r2,-8(fp)
   8ae18:	00000106 	br	8ae20 <close+0x8c>
   8ae1c:	e03ffe15 	stw	zero,-8(fp)
   8ae20:	e0bffe17 	ldw	r2,-8(fp)
   8ae24:	e0bffa15 	stw	r2,-24(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
   8ae28:	e13ffc17 	ldw	r4,-16(fp)
   8ae2c:	008b1100 	call	8b110 <alt_release_fd>
    if (rval < 0)
   8ae30:	e0bffa17 	ldw	r2,-24(fp)
   8ae34:	1004403a 	cmpge	r2,r2,zero
   8ae38:	1000071e 	bne	r2,zero,8ae58 <close+0xc4>
    {
      ALT_ERRNO = -rval;
   8ae3c:	008ae900 	call	8ae90 <alt_get_errno>
   8ae40:	e0fffa17 	ldw	r3,-24(fp)
   8ae44:	00c7c83a 	sub	r3,zero,r3
   8ae48:	10c00015 	stw	r3,0(r2)
      return -1;
   8ae4c:	00bfffc4 	movi	r2,-1
   8ae50:	e0bffd15 	stw	r2,-12(fp)
   8ae54:	00000806 	br	8ae78 <close+0xe4>
    }
    return 0;
   8ae58:	e03ffd15 	stw	zero,-12(fp)
   8ae5c:	00000606 	br	8ae78 <close+0xe4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
   8ae60:	008ae900 	call	8ae90 <alt_get_errno>
   8ae64:	1007883a 	mov	r3,r2
   8ae68:	00801444 	movi	r2,81
   8ae6c:	18800015 	stw	r2,0(r3)
    return -1;
   8ae70:	00bfffc4 	movi	r2,-1
   8ae74:	e0bffd15 	stw	r2,-12(fp)
   8ae78:	e0bffd17 	ldw	r2,-12(fp)
  }
}
   8ae7c:	e037883a 	mov	sp,fp
   8ae80:	dfc00117 	ldw	ra,4(sp)
   8ae84:	df000017 	ldw	fp,0(sp)
   8ae88:	dec00204 	addi	sp,sp,8
   8ae8c:	f800283a 	ret

0008ae90 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   8ae90:	defffd04 	addi	sp,sp,-12
   8ae94:	dfc00215 	stw	ra,8(sp)
   8ae98:	df000115 	stw	fp,4(sp)
   8ae9c:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
   8aea0:	00800274 	movhi	r2,9
   8aea4:	10ae5e04 	addi	r2,r2,-18056
   8aea8:	10800017 	ldw	r2,0(r2)
   8aeac:	1005003a 	cmpeq	r2,r2,zero
   8aeb0:	1000061e 	bne	r2,zero,8aecc <alt_get_errno+0x3c>
   8aeb4:	00800274 	movhi	r2,9
   8aeb8:	10ae5e04 	addi	r2,r2,-18056
   8aebc:	10800017 	ldw	r2,0(r2)
   8aec0:	103ee83a 	callr	r2
   8aec4:	e0bfff15 	stw	r2,-4(fp)
   8aec8:	00000306 	br	8aed8 <alt_get_errno+0x48>
   8aecc:	00800274 	movhi	r2,9
   8aed0:	10af2e04 	addi	r2,r2,-17224
   8aed4:	e0bfff15 	stw	r2,-4(fp)
   8aed8:	e0bfff17 	ldw	r2,-4(fp)
}
   8aedc:	e037883a 	mov	sp,fp
   8aee0:	dfc00117 	ldw	ra,4(sp)
   8aee4:	df000017 	ldw	fp,0(sp)
   8aee8:	dec00204 	addi	sp,sp,8
   8aeec:	f800283a 	ret

0008aef0 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   8aef0:	deffff04 	addi	sp,sp,-4
   8aef4:	df000015 	stw	fp,0(sp)
   8aef8:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   8aefc:	e037883a 	mov	sp,fp
   8af00:	df000017 	ldw	fp,0(sp)
   8af04:	dec00104 	addi	sp,sp,4
   8af08:	f800283a 	ret

0008af0c <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
   8af0c:	defffc04 	addi	sp,sp,-16
   8af10:	df000315 	stw	fp,12(sp)
   8af14:	df000304 	addi	fp,sp,12
   8af18:	e13ffd15 	stw	r4,-12(fp)
   8af1c:	e17ffe15 	stw	r5,-8(fp)
   8af20:	e1bfff15 	stw	r6,-4(fp)
  return len;
   8af24:	e0bfff17 	ldw	r2,-4(fp)
}
   8af28:	e037883a 	mov	sp,fp
   8af2c:	df000017 	ldw	fp,0(sp)
   8af30:	dec00104 	addi	sp,sp,4
   8af34:	f800283a 	ret

0008af38 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
   8af38:	defff904 	addi	sp,sp,-28
   8af3c:	dfc00615 	stw	ra,24(sp)
   8af40:	df000515 	stw	fp,20(sp)
   8af44:	df000504 	addi	fp,sp,20
   8af48:	e13ffd15 	stw	r4,-12(fp)
   8af4c:	e17ffe15 	stw	r5,-8(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
   8af50:	e0bffd17 	ldw	r2,-12(fp)
   8af54:	1005003a 	cmpeq	r2,r2,zero
   8af58:	1000041e 	bne	r2,zero,8af6c <alt_dev_llist_insert+0x34>
   8af5c:	e0bffd17 	ldw	r2,-12(fp)
   8af60:	10800217 	ldw	r2,8(r2)
   8af64:	1004c03a 	cmpne	r2,r2,zero
   8af68:	1000071e 	bne	r2,zero,8af88 <alt_dev_llist_insert+0x50>
  {
    ALT_ERRNO = EINVAL;
   8af6c:	008afec0 	call	8afec <alt_get_errno>
   8af70:	1007883a 	mov	r3,r2
   8af74:	00800584 	movi	r2,22
   8af78:	18800015 	stw	r2,0(r3)
    return -EINVAL;
   8af7c:	00bffa84 	movi	r2,-22
   8af80:	e0bfff15 	stw	r2,-4(fp)
   8af84:	00001306 	br	8afd4 <alt_dev_llist_insert+0x9c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
   8af88:	e0fffd17 	ldw	r3,-12(fp)
   8af8c:	e0bffe17 	ldw	r2,-8(fp)
   8af90:	e0bffb15 	stw	r2,-20(fp)
   8af94:	e0fffc15 	stw	r3,-16(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   8af98:	e0fffc17 	ldw	r3,-16(fp)
   8af9c:	e0bffb17 	ldw	r2,-20(fp)
   8afa0:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
   8afa4:	e0bffb17 	ldw	r2,-20(fp)
   8afa8:	10c00017 	ldw	r3,0(r2)
   8afac:	e0bffc17 	ldw	r2,-16(fp)
   8afb0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   8afb4:	e0bffb17 	ldw	r2,-20(fp)
   8afb8:	10c00017 	ldw	r3,0(r2)
   8afbc:	e0bffc17 	ldw	r2,-16(fp)
   8afc0:	18800115 	stw	r2,4(r3)
  list->next           = entry;
   8afc4:	e0fffb17 	ldw	r3,-20(fp)
   8afc8:	e0bffc17 	ldw	r2,-16(fp)
   8afcc:	18800015 	stw	r2,0(r3)

  return 0;  
   8afd0:	e03fff15 	stw	zero,-4(fp)
   8afd4:	e0bfff17 	ldw	r2,-4(fp)
}
   8afd8:	e037883a 	mov	sp,fp
   8afdc:	dfc00117 	ldw	ra,4(sp)
   8afe0:	df000017 	ldw	fp,0(sp)
   8afe4:	dec00204 	addi	sp,sp,8
   8afe8:	f800283a 	ret

0008afec <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   8afec:	defffd04 	addi	sp,sp,-12
   8aff0:	dfc00215 	stw	ra,8(sp)
   8aff4:	df000115 	stw	fp,4(sp)
   8aff8:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
   8affc:	00800274 	movhi	r2,9
   8b000:	10ae5e04 	addi	r2,r2,-18056
   8b004:	10800017 	ldw	r2,0(r2)
   8b008:	1005003a 	cmpeq	r2,r2,zero
   8b00c:	1000061e 	bne	r2,zero,8b028 <alt_get_errno+0x3c>
   8b010:	00800274 	movhi	r2,9
   8b014:	10ae5e04 	addi	r2,r2,-18056
   8b018:	10800017 	ldw	r2,0(r2)
   8b01c:	103ee83a 	callr	r2
   8b020:	e0bfff15 	stw	r2,-4(fp)
   8b024:	00000306 	br	8b034 <alt_get_errno+0x48>
   8b028:	00800274 	movhi	r2,9
   8b02c:	10af2e04 	addi	r2,r2,-17224
   8b030:	e0bfff15 	stw	r2,-4(fp)
   8b034:	e0bfff17 	ldw	r2,-4(fp)
}
   8b038:	e037883a 	mov	sp,fp
   8b03c:	dfc00117 	ldw	ra,4(sp)
   8b040:	df000017 	ldw	fp,0(sp)
   8b044:	dec00204 	addi	sp,sp,8
   8b048:	f800283a 	ret

0008b04c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   8b04c:	defff904 	addi	sp,sp,-28
   8b050:	dfc00615 	stw	ra,24(sp)
   8b054:	df000515 	stw	fp,20(sp)
   8b058:	df000504 	addi	fp,sp,20
   8b05c:	e13ffd15 	stw	r4,-12(fp)
   8b060:	e17ffe15 	stw	r5,-8(fp)
  alt_dev* next = (alt_dev*) llist->next;
   8b064:	e0bffe17 	ldw	r2,-8(fp)
   8b068:	10800017 	ldw	r2,0(r2)
   8b06c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
   8b070:	e13ffd17 	ldw	r4,-12(fp)
   8b074:	008b27c0 	call	8b27c <strlen>
   8b078:	10800044 	addi	r2,r2,1
   8b07c:	e0bffb15 	stw	r2,-20(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   8b080:	00000d06 	br	8b0b8 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   8b084:	e0bffc17 	ldw	r2,-16(fp)
   8b088:	11000217 	ldw	r4,8(r2)
   8b08c:	e1bffb17 	ldw	r6,-20(fp)
   8b090:	e17ffd17 	ldw	r5,-12(fp)
   8b094:	008b2400 	call	8b240 <memcmp>
   8b098:	1004c03a 	cmpne	r2,r2,zero
   8b09c:	1000031e 	bne	r2,zero,8b0ac <alt_find_dev+0x60>
    {
      /* match found */

      return next;
   8b0a0:	e0bffc17 	ldw	r2,-16(fp)
   8b0a4:	e0bfff15 	stw	r2,-4(fp)
   8b0a8:	00000706 	br	8b0c8 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
   8b0ac:	e0bffc17 	ldw	r2,-16(fp)
   8b0b0:	10800017 	ldw	r2,0(r2)
   8b0b4:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   8b0b8:	e0fffe17 	ldw	r3,-8(fp)
   8b0bc:	e0bffc17 	ldw	r2,-16(fp)
   8b0c0:	10fff01e 	bne	r2,r3,8b084 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
   8b0c4:	e03fff15 	stw	zero,-4(fp)
   8b0c8:	e0bfff17 	ldw	r2,-4(fp)
}
   8b0cc:	e037883a 	mov	sp,fp
   8b0d0:	dfc00117 	ldw	ra,4(sp)
   8b0d4:	df000017 	ldw	fp,0(sp)
   8b0d8:	dec00204 	addi	sp,sp,8
   8b0dc:	f800283a 	ret

0008b0e0 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   8b0e0:	defffe04 	addi	sp,sp,-8
   8b0e4:	dfc00115 	stw	ra,4(sp)
   8b0e8:	df000015 	stw	fp,0(sp)
   8b0ec:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
   8b0f0:	0009883a 	mov	r4,zero
   8b0f4:	01410004 	movi	r5,1024
   8b0f8:	008b1900 	call	8b190 <alt_icache_flush>
#endif
}
   8b0fc:	e037883a 	mov	sp,fp
   8b100:	dfc00117 	ldw	ra,4(sp)
   8b104:	df000017 	ldw	fp,0(sp)
   8b108:	dec00204 	addi	sp,sp,8
   8b10c:	f800283a 	ret

0008b110 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
   8b110:	defffe04 	addi	sp,sp,-8
   8b114:	df000115 	stw	fp,4(sp)
   8b118:	df000104 	addi	fp,sp,4
   8b11c:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
   8b120:	e0bfff17 	ldw	r2,-4(fp)
   8b124:	108000d0 	cmplti	r2,r2,3
   8b128:	10000d1e 	bne	r2,zero,8b160 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
   8b12c:	e0bfff17 	ldw	r2,-4(fp)
   8b130:	00c00274 	movhi	r3,9
   8b134:	18edc104 	addi	r3,r3,-18684
   8b138:	10800324 	muli	r2,r2,12
   8b13c:	10c5883a 	add	r2,r2,r3
   8b140:	10800204 	addi	r2,r2,8
   8b144:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
   8b148:	e0bfff17 	ldw	r2,-4(fp)
   8b14c:	00c00274 	movhi	r3,9
   8b150:	18edc104 	addi	r3,r3,-18684
   8b154:	10800324 	muli	r2,r2,12
   8b158:	10c5883a 	add	r2,r2,r3
   8b15c:	10000015 	stw	zero,0(r2)
  }
}
   8b160:	e037883a 	mov	sp,fp
   8b164:	df000017 	ldw	fp,0(sp)
   8b168:	dec00104 	addi	sp,sp,4
   8b16c:	f800283a 	ret

0008b170 <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
   8b170:	deffff04 	addi	sp,sp,-4
   8b174:	df000015 	stw	fp,0(sp)
   8b178:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
   8b17c:	000170fa 	wrctl	ienable,zero
}
   8b180:	e037883a 	mov	sp,fp
   8b184:	df000017 	ldw	fp,0(sp)
   8b188:	dec00104 	addi	sp,sp,4
   8b18c:	f800283a 	ret

0008b190 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
   8b190:	defffb04 	addi	sp,sp,-20
   8b194:	df000415 	stw	fp,16(sp)
   8b198:	df000404 	addi	fp,sp,16
   8b19c:	e13ffe15 	stw	r4,-8(fp)
   8b1a0:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
   8b1a4:	e0bfff17 	ldw	r2,-4(fp)
   8b1a8:	10810070 	cmpltui	r2,r2,1025
   8b1ac:	1000021e 	bne	r2,zero,8b1b8 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
   8b1b0:	00810004 	movi	r2,1024
   8b1b4:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
   8b1b8:	e0fffe17 	ldw	r3,-8(fp)
   8b1bc:	e0bfff17 	ldw	r2,-4(fp)
   8b1c0:	1885883a 	add	r2,r3,r2
   8b1c4:	e0bffc15 	stw	r2,-16(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   8b1c8:	e0bffe17 	ldw	r2,-8(fp)
   8b1cc:	e0bffd15 	stw	r2,-12(fp)
   8b1d0:	00000506 	br	8b1e8 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
   8b1d4:	e0bffd17 	ldw	r2,-12(fp)
   8b1d8:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   8b1dc:	e0bffd17 	ldw	r2,-12(fp)
   8b1e0:	10800804 	addi	r2,r2,32
   8b1e4:	e0bffd15 	stw	r2,-12(fp)
   8b1e8:	e0fffd17 	ldw	r3,-12(fp)
   8b1ec:	e0bffc17 	ldw	r2,-16(fp)
   8b1f0:	18bff836 	bltu	r3,r2,8b1d4 <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
   8b1f4:	e0bffe17 	ldw	r2,-8(fp)
   8b1f8:	108007cc 	andi	r2,r2,31
   8b1fc:	1005003a 	cmpeq	r2,r2,zero
   8b200:	1000021e 	bne	r2,zero,8b20c <alt_icache_flush+0x7c>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
   8b204:	e0bffd17 	ldw	r2,-12(fp)
   8b208:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
   8b20c:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
   8b210:	e037883a 	mov	sp,fp
   8b214:	df000017 	ldw	fp,0(sp)
   8b218:	dec00104 	addi	sp,sp,4
   8b21c:	f800283a 	ret

0008b220 <exit>:
   8b220:	defffe04 	addi	sp,sp,-8
   8b224:	dc400015 	stw	r17,0(sp)
   8b228:	000b883a 	mov	r5,zero
   8b22c:	2023883a 	mov	r17,r4
   8b230:	dfc00115 	stw	ra,4(sp)
   8b234:	008b2a00 	call	8b2a0 <__call_exitprocs>
   8b238:	8809883a 	mov	r4,r17
   8b23c:	008b5e80 	call	8b5e8 <_exit>

0008b240 <memcmp>:
   8b240:	31ffffc4 	addi	r7,r6,-1
   8b244:	3000061e 	bne	r6,zero,8b260 <memcmp+0x20>
   8b248:	00000a06 	br	8b274 <memcmp+0x34>
   8b24c:	39ffffc4 	addi	r7,r7,-1
   8b250:	00bfffc4 	movi	r2,-1
   8b254:	21000044 	addi	r4,r4,1
   8b258:	29400044 	addi	r5,r5,1
   8b25c:	38800526 	beq	r7,r2,8b274 <memcmp+0x34>
   8b260:	20c00003 	ldbu	r3,0(r4)
   8b264:	28800003 	ldbu	r2,0(r5)
   8b268:	18bff826 	beq	r3,r2,8b24c <memcmp+0xc>
   8b26c:	1885c83a 	sub	r2,r3,r2
   8b270:	f800283a 	ret
   8b274:	0005883a 	mov	r2,zero
   8b278:	f800283a 	ret

0008b27c <strlen>:
   8b27c:	20800007 	ldb	r2,0(r4)
   8b280:	10000526 	beq	r2,zero,8b298 <strlen+0x1c>
   8b284:	2007883a 	mov	r3,r4
   8b288:	18c00044 	addi	r3,r3,1
   8b28c:	18800007 	ldb	r2,0(r3)
   8b290:	103ffd1e 	bne	r2,zero,8b288 <strlen+0xc>
   8b294:	1905c83a 	sub	r2,r3,r4
   8b298:	f800283a 	ret

0008b29c <register_fini>:
   8b29c:	f800283a 	ret

0008b2a0 <__call_exitprocs>:
   8b2a0:	defff304 	addi	sp,sp,-52
   8b2a4:	00800274 	movhi	r2,9
   8b2a8:	10ae6004 	addi	r2,r2,-18048
   8b2ac:	df000b15 	stw	fp,44(sp)
   8b2b0:	17000017 	ldw	fp,0(r2)
   8b2b4:	00800034 	movhi	r2,0
   8b2b8:	10800004 	addi	r2,r2,0
   8b2bc:	1005003a 	cmpeq	r2,r2,zero
   8b2c0:	d8800215 	stw	r2,8(sp)
   8b2c4:	e0800c04 	addi	r2,fp,48
   8b2c8:	dd800915 	stw	r22,36(sp)
   8b2cc:	dd400815 	stw	r21,32(sp)
   8b2d0:	dfc00c15 	stw	ra,48(sp)
   8b2d4:	ddc00a15 	stw	r23,40(sp)
   8b2d8:	dd000715 	stw	r20,28(sp)
   8b2dc:	dcc00615 	stw	r19,24(sp)
   8b2e0:	dc800515 	stw	r18,20(sp)
   8b2e4:	dc400415 	stw	r17,16(sp)
   8b2e8:	dc000315 	stw	r16,12(sp)
   8b2ec:	282d883a 	mov	r22,r5
   8b2f0:	d9000115 	stw	r4,4(sp)
   8b2f4:	d8800015 	stw	r2,0(sp)
   8b2f8:	282b003a 	cmpeq	r21,r5,zero
   8b2fc:	e4400c17 	ldw	r17,48(fp)
   8b300:	88001226 	beq	r17,zero,8b34c <__call_exitprocs+0xac>
   8b304:	ddc00017 	ldw	r23,0(sp)
   8b308:	88800117 	ldw	r2,4(r17)
   8b30c:	8c802217 	ldw	r18,136(r17)
   8b310:	143fffc4 	addi	r16,r2,-1
   8b314:	80000b16 	blt	r16,zero,8b344 <__call_exitprocs+0xa4>
   8b318:	9027003a 	cmpeq	r19,r18,zero
   8b31c:	a800171e 	bne	r21,zero,8b37c <__call_exitprocs+0xdc>
   8b320:	9800051e 	bne	r19,zero,8b338 <__call_exitprocs+0x98>
   8b324:	8409883a 	add	r4,r16,r16
   8b328:	2105883a 	add	r2,r4,r4
   8b32c:	1485883a 	add	r2,r2,r18
   8b330:	10c02017 	ldw	r3,128(r2)
   8b334:	b0c01226 	beq	r22,r3,8b380 <__call_exitprocs+0xe0>
   8b338:	843fffc4 	addi	r16,r16,-1
   8b33c:	00bfffc4 	movi	r2,-1
   8b340:	80bff61e 	bne	r16,r2,8b31c <__call_exitprocs+0x7c>
   8b344:	d8800217 	ldw	r2,8(sp)
   8b348:	10003226 	beq	r2,zero,8b414 <__call_exitprocs+0x174>
   8b34c:	dfc00c17 	ldw	ra,48(sp)
   8b350:	df000b17 	ldw	fp,44(sp)
   8b354:	ddc00a17 	ldw	r23,40(sp)
   8b358:	dd800917 	ldw	r22,36(sp)
   8b35c:	dd400817 	ldw	r21,32(sp)
   8b360:	dd000717 	ldw	r20,28(sp)
   8b364:	dcc00617 	ldw	r19,24(sp)
   8b368:	dc800517 	ldw	r18,20(sp)
   8b36c:	dc400417 	ldw	r17,16(sp)
   8b370:	dc000317 	ldw	r16,12(sp)
   8b374:	dec00d04 	addi	sp,sp,52
   8b378:	f800283a 	ret
   8b37c:	8409883a 	add	r4,r16,r16
   8b380:	88c00117 	ldw	r3,4(r17)
   8b384:	2105883a 	add	r2,r4,r4
   8b388:	1445883a 	add	r2,r2,r17
   8b38c:	18ffffc4 	addi	r3,r3,-1
   8b390:	11800217 	ldw	r6,8(r2)
   8b394:	1c001826 	beq	r3,r16,8b3f8 <__call_exitprocs+0x158>
   8b398:	10000215 	stw	zero,8(r2)
   8b39c:	303fe626 	beq	r6,zero,8b338 <__call_exitprocs+0x98>
   8b3a0:	8d000117 	ldw	r20,4(r17)
   8b3a4:	9800121e 	bne	r19,zero,8b3f0 <__call_exitprocs+0x150>
   8b3a8:	00c00044 	movi	r3,1
   8b3ac:	1c06983a 	sll	r3,r3,r16
   8b3b0:	90804017 	ldw	r2,256(r18)
   8b3b4:	1884703a 	and	r2,r3,r2
   8b3b8:	10000d26 	beq	r2,zero,8b3f0 <__call_exitprocs+0x150>
   8b3bc:	90804117 	ldw	r2,260(r18)
   8b3c0:	1884703a 	and	r2,r3,r2
   8b3c4:	10000e1e 	bne	r2,zero,8b400 <__call_exitprocs+0x160>
   8b3c8:	2105883a 	add	r2,r4,r4
   8b3cc:	1485883a 	add	r2,r2,r18
   8b3d0:	11400017 	ldw	r5,0(r2)
   8b3d4:	d9000117 	ldw	r4,4(sp)
   8b3d8:	303ee83a 	callr	r6
   8b3dc:	88800117 	ldw	r2,4(r17)
   8b3e0:	a0bfc61e 	bne	r20,r2,8b2fc <__call_exitprocs+0x5c>
   8b3e4:	b8800017 	ldw	r2,0(r23)
   8b3e8:	147fd326 	beq	r2,r17,8b338 <__call_exitprocs+0x98>
   8b3ec:	003fc306 	br	8b2fc <__call_exitprocs+0x5c>
   8b3f0:	303ee83a 	callr	r6
   8b3f4:	003ff906 	br	8b3dc <__call_exitprocs+0x13c>
   8b3f8:	8c000115 	stw	r16,4(r17)
   8b3fc:	003fe706 	br	8b39c <__call_exitprocs+0xfc>
   8b400:	2105883a 	add	r2,r4,r4
   8b404:	1485883a 	add	r2,r2,r18
   8b408:	11000017 	ldw	r4,0(r2)
   8b40c:	303ee83a 	callr	r6
   8b410:	003ff206 	br	8b3dc <__call_exitprocs+0x13c>
   8b414:	88800117 	ldw	r2,4(r17)
   8b418:	10000b1e 	bne	r2,zero,8b448 <__call_exitprocs+0x1a8>
   8b41c:	89000017 	ldw	r4,0(r17)
   8b420:	20000a26 	beq	r4,zero,8b44c <__call_exitprocs+0x1ac>
   8b424:	b9000015 	stw	r4,0(r23)
   8b428:	90000226 	beq	r18,zero,8b434 <__call_exitprocs+0x194>
   8b42c:	9009883a 	mov	r4,r18
   8b430:	00000000 	call	0 <__reset-0x88000>
   8b434:	8809883a 	mov	r4,r17
   8b438:	00000000 	call	0 <__reset-0x88000>
   8b43c:	bc400017 	ldw	r17,0(r23)
   8b440:	883fb11e 	bne	r17,zero,8b308 <__call_exitprocs+0x68>
   8b444:	003fc106 	br	8b34c <__call_exitprocs+0xac>
   8b448:	89000017 	ldw	r4,0(r17)
   8b44c:	882f883a 	mov	r23,r17
   8b450:	2023883a 	mov	r17,r4
   8b454:	883fac1e 	bne	r17,zero,8b308 <__call_exitprocs+0x68>
   8b458:	003fbc06 	br	8b34c <__call_exitprocs+0xac>

0008b45c <udivmodsi4>:
   8b45c:	29001b2e 	bgeu	r5,r4,8b4cc <udivmodsi4+0x70>
   8b460:	28001a16 	blt	r5,zero,8b4cc <udivmodsi4+0x70>
   8b464:	00800044 	movi	r2,1
   8b468:	0007883a 	mov	r3,zero
   8b46c:	01c007c4 	movi	r7,31
   8b470:	00000306 	br	8b480 <udivmodsi4+0x24>
   8b474:	19c01326 	beq	r3,r7,8b4c4 <udivmodsi4+0x68>
   8b478:	18c00044 	addi	r3,r3,1
   8b47c:	28000416 	blt	r5,zero,8b490 <udivmodsi4+0x34>
   8b480:	294b883a 	add	r5,r5,r5
   8b484:	1085883a 	add	r2,r2,r2
   8b488:	293ffa36 	bltu	r5,r4,8b474 <udivmodsi4+0x18>
   8b48c:	10000d26 	beq	r2,zero,8b4c4 <udivmodsi4+0x68>
   8b490:	0007883a 	mov	r3,zero
   8b494:	21400236 	bltu	r4,r5,8b4a0 <udivmodsi4+0x44>
   8b498:	2149c83a 	sub	r4,r4,r5
   8b49c:	1886b03a 	or	r3,r3,r2
   8b4a0:	1004d07a 	srli	r2,r2,1
   8b4a4:	280ad07a 	srli	r5,r5,1
   8b4a8:	103ffa1e 	bne	r2,zero,8b494 <udivmodsi4+0x38>
   8b4ac:	30000226 	beq	r6,zero,8b4b8 <udivmodsi4+0x5c>
   8b4b0:	2005883a 	mov	r2,r4
   8b4b4:	f800283a 	ret
   8b4b8:	1809883a 	mov	r4,r3
   8b4bc:	2005883a 	mov	r2,r4
   8b4c0:	f800283a 	ret
   8b4c4:	0007883a 	mov	r3,zero
   8b4c8:	003ff806 	br	8b4ac <udivmodsi4+0x50>
   8b4cc:	00800044 	movi	r2,1
   8b4d0:	0007883a 	mov	r3,zero
   8b4d4:	003fef06 	br	8b494 <udivmodsi4+0x38>

0008b4d8 <__divsi3>:
   8b4d8:	defffe04 	addi	sp,sp,-8
   8b4dc:	dc000015 	stw	r16,0(sp)
   8b4e0:	dfc00115 	stw	ra,4(sp)
   8b4e4:	0021883a 	mov	r16,zero
   8b4e8:	20000c16 	blt	r4,zero,8b51c <__divsi3+0x44>
   8b4ec:	000d883a 	mov	r6,zero
   8b4f0:	28000e16 	blt	r5,zero,8b52c <__divsi3+0x54>
   8b4f4:	008b45c0 	call	8b45c <udivmodsi4>
   8b4f8:	1007883a 	mov	r3,r2
   8b4fc:	8005003a 	cmpeq	r2,r16,zero
   8b500:	1000011e 	bne	r2,zero,8b508 <__divsi3+0x30>
   8b504:	00c7c83a 	sub	r3,zero,r3
   8b508:	1805883a 	mov	r2,r3
   8b50c:	dfc00117 	ldw	ra,4(sp)
   8b510:	dc000017 	ldw	r16,0(sp)
   8b514:	dec00204 	addi	sp,sp,8
   8b518:	f800283a 	ret
   8b51c:	0109c83a 	sub	r4,zero,r4
   8b520:	04000044 	movi	r16,1
   8b524:	000d883a 	mov	r6,zero
   8b528:	283ff20e 	bge	r5,zero,8b4f4 <__divsi3+0x1c>
   8b52c:	014bc83a 	sub	r5,zero,r5
   8b530:	8021003a 	cmpeq	r16,r16,zero
   8b534:	003fef06 	br	8b4f4 <__divsi3+0x1c>

0008b538 <__modsi3>:
   8b538:	deffff04 	addi	sp,sp,-4
   8b53c:	dfc00015 	stw	ra,0(sp)
   8b540:	01800044 	movi	r6,1
   8b544:	2807883a 	mov	r3,r5
   8b548:	20000416 	blt	r4,zero,8b55c <__modsi3+0x24>
   8b54c:	28000c16 	blt	r5,zero,8b580 <__modsi3+0x48>
   8b550:	dfc00017 	ldw	ra,0(sp)
   8b554:	dec00104 	addi	sp,sp,4
   8b558:	008b45c1 	jmpi	8b45c <udivmodsi4>
   8b55c:	0109c83a 	sub	r4,zero,r4
   8b560:	28000b16 	blt	r5,zero,8b590 <__modsi3+0x58>
   8b564:	180b883a 	mov	r5,r3
   8b568:	01800044 	movi	r6,1
   8b56c:	008b45c0 	call	8b45c <udivmodsi4>
   8b570:	0085c83a 	sub	r2,zero,r2
   8b574:	dfc00017 	ldw	ra,0(sp)
   8b578:	dec00104 	addi	sp,sp,4
   8b57c:	f800283a 	ret
   8b580:	014bc83a 	sub	r5,zero,r5
   8b584:	dfc00017 	ldw	ra,0(sp)
   8b588:	dec00104 	addi	sp,sp,4
   8b58c:	008b45c1 	jmpi	8b45c <udivmodsi4>
   8b590:	0147c83a 	sub	r3,zero,r5
   8b594:	003ff306 	br	8b564 <__modsi3+0x2c>

0008b598 <__udivsi3>:
   8b598:	000d883a 	mov	r6,zero
   8b59c:	008b45c1 	jmpi	8b45c <udivmodsi4>

0008b5a0 <__umodsi3>:
   8b5a0:	01800044 	movi	r6,1
   8b5a4:	008b45c1 	jmpi	8b45c <udivmodsi4>

0008b5a8 <alt_sim_halt>:

/*
 * Routine called on exit.
 */
static ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
   8b5a8:	defffd04 	addi	sp,sp,-12
   8b5ac:	df000215 	stw	fp,8(sp)
   8b5b0:	df000204 	addi	fp,sp,8
   8b5b4:	e13fff15 	stw	r4,-4(fp)
  int r2 = exit_code;
   8b5b8:	e0bfff17 	ldw	r2,-4(fp)
   8b5bc:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
   8b5c0:	e0bffe17 	ldw	r2,-8(fp)
   8b5c4:	1005003a 	cmpeq	r2,r2,zero
   8b5c8:	1000021e 	bne	r2,zero,8b5d4 <alt_sim_halt+0x2c>
    ALT_SIM_FAIL();
   8b5cc:	002af070 	cmpltui	zero,zero,43969
   8b5d0:	00000106 	br	8b5d8 <alt_sim_halt+0x30>
  } else {
    ALT_SIM_PASS();
   8b5d4:	002af0b0 	cmpltui	zero,zero,43970
  }
#endif /* DEBUG_STUB */
}
   8b5d8:	e037883a 	mov	sp,fp
   8b5dc:	df000017 	ldw	fp,0(sp)
   8b5e0:	dec00104 	addi	sp,sp,4
   8b5e4:	f800283a 	ret

0008b5e8 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
   8b5e8:	defffd04 	addi	sp,sp,-12
   8b5ec:	dfc00215 	stw	ra,8(sp)
   8b5f0:	df000115 	stw	fp,4(sp)
   8b5f4:	df000104 	addi	fp,sp,4
   8b5f8:	e13fff15 	stw	r4,-4(fp)
  ALT_OS_STOP();

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
  ALT_SIM_HALT(exit_code);
   8b5fc:	e13fff17 	ldw	r4,-4(fp)
   8b600:	008b5a80 	call	8b5a8 <alt_sim_halt>

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
   8b604:	003fff06 	br	8b604 <_exit+0x1c>
   8b608:	0008b29c 	xori	zero,zero,8906
